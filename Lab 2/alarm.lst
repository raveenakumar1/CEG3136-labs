D:\Lab2\Lab2Students\AlarmAssembler\alarm.lst - generated by MGTEK Assembler ASM12 V1.26 Build 144 for WIN32 (x86) - Mon Sep 30 12:29:03 2019

    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: alarm.asm (Alarm System Module)
    4:                                 ; Author: Gilbert Arbez
    5:                                 ; Date: Fall 2010
    6:                                 ;------------------------------------------------------
   10:                                 
   11:                                 ; Some definitions
   12:                                 ; Location of the register block
   13:          =00000000              Regblk:       equ    $0000 
   14:                                  INCLUDE sections.inc
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
    9:          =00000001              SECTIONS_DEFINED   EQU  1        ; prevents future inclusion of the file
   10:                                 
   11:                                 ; Define addresses of various sections
   12:          =00003000              VARIABLES EQU $3000   ; $3000 - $3FFF
   13:          =00002000              PROGRAM   EQU $2000  ; $2000 - $2FFF
   14:          =00002000              STACK     EQU $2000  ; $1000 - $1FFF
   15:                                 
   16:                                 ;----------------------------------------
   17:                                 ; Global Variable section
   18:                                 ; Use the DS - define storage directive
   19:                                 ;              to define space for 
   20:                                 ;              global variables and data
   21:                                 ;              structures.
   22:                                 ;----------------------------------------
   23:                                 globalVar SECTION
   24:          =00003000                      ORG VARIABLES   ; places section in RAM
   25:                                 ;-----------------------------------------
   26:                                 ; Code section
   27:                                 ; Enter assembly instructions (HCS12) to create
   28:                                 ; executable code.
   29:                                 ;-----------------------------------------
   30:                                 code_section SECTION
   31:          =00002000                      ORG PROGRAM  ; places section in RAM - simulates ROM
   32:                                 
   33:                                 ;------------------------------------------
   34:                                 ; Global constants
   35:                                 ; In simple programs (single module) global constants are 
   36:                                 ; simply placed at the end of code and not section is
   37:                                 ; explicitly defined.
   38:                                 ;--------------------------------------------
   39:                                 globalConst SECTION
   40:          =00002398                      ORG ENDCODE ;--ENDCODE is defined on the second pass of the assembler
   41:                                 
   42:                                 ;----------------------------------------------
   43:                                 ; Defining the start of the globalConst Section
   44:                                 ; The following should be added to the end of the 
   45:                                 ; main module
   46:                                 ;----------------------------------------------
   47:                                 ;       SWITCH code_section 
   48:                                 ;ENDCODE        
   49:                                 
   50:                                          ENDIF  ; End of conditional assembly
   15:                                  INCLUDE alarm.inc
    1:                                 ;---------------------------------
    2:                                 ; File: alarmSimul.inc
    3:                                 ; Description: Include file for Alarm System Simulation
    4:                                 ;              project
    5:                                 ;----------------------------------------------
    6:                                         IFNDEF ALARM_SIMUL_HDR  ; Start of conditional assembly
    7:          =00000001              ALARM_SIMUL_HDR   EQU   1        ; prevents future inclusion of the file
    8:                                 
    9:                                 ; for calculating wins
   10:          =000000FF              NOCHAR        equ    0xff
   11:          =00000007              BEL           equ    0x07
   12:          =00000001              TRUE          equ    1
   13:          =00000000              FALSE         equ    0
   14:          =00000005              NUMCODES      equ    5
   15:          =00000008              XWINSUM        equ   ('X'+'X'+'X')&$FF  ; sum of three X's
   16:          =000000ED              OWINSUM        equ   'O'+'O'+'O'        ; sum of three O's
   17:          =0000000A              NL             equ   $0a                ; NEWLINE
   18:          =0000000D              CR             equ   $0d                ; carriage return
   19:          =00000030              ASCII_CONV_NUM equ   $30                ; For converting digit to ASCII
   20:                                 
   21:                                          ENDIF  ; End of conditional assembly
   16:                                 
   17:                                 ; Dbug12 subroutines
   18:          =0000EE86              putchar        equ   $EE86
   19:          =0000EE84              getchar        equ   $EE84
   20:          =0000EE88              printf         equ   $EE88
   21:          =0000EEA6              writeEEByte    equ   $EEA6
   22:                                 
   23:                                         switch code_section
   24:                                 ;------------------------------------------------------
   25:                                 ; Alarm System Module
   26:                                 
   27:                                 ; Main routine
   28:                                 ; Variables: select - in register B (set by getchar)
   29:                                 ; Description: The main routine for running the game.
   30:                                 ;              Initialises things (via initgb) and the
   31:                                 ;              loops forever playing games.
   32:                                 ;------------------------------------------------------
   33:     2000 CF 2000                        lds #STACK       ; Not reflected in C
   34:     2003 07 26                          bsr inithw       ; initiliase the hardware
   35:     2005 16 235E                        jsr initKeyPad   ;  initKeyPad();
   36:     2008 16 2388                        jsr initSwitches ;  initSwithes();
   37:                                         ; byte select - in register B
   38:                                                         ;do
   39:     200B                        mainloop:                       ; {
   40:     200B CC 23A2                        ldd #MENU          ;   printf(MENU);
   41:     200E 15 FB CE76                     jsr [printf,PCr] 
   42:     2012 17 00                          jsr readKey        ;   select = readKey();
   43:     2014 37                             pshb ; save b
   44:     2015 33                             pulb
   45:     2016 C1 63                          cmpb #'c'          ;   if(select == 'c') configCodes();
   46:     2018 26 05                          bne mnElseif
   47:     201A 16 2061                        jsr configCodes
   48:     201D 20 09                          bra mnEndif
   49:     201F C1 61                  mnElseif cmpb #'a'         ;   else if(select == 'a') enableAlarm();
   50:     2021 26 05                          bne mnElse
   51:     2023 16 21B8                        jsr enableAlarm
   52:     2026 20 00                          bra mnEndif
   53:     2028                        mnElse                     ;   else /*do nothing*/;
   54:     2028                        mnEndif:
   55:     2028 20 E1                          bra mainloop       ; } while(1);  // loop forever
   56:     202A 3F                             swi                ; never reach here - infinite loop
   57:                                 
   58:                                 ;------------------------------------------------------
   59:                                 ; Subroutine: inithw
   60:                                 ; No parameters
   61:                                 ; Variables: ptx - index register X
   62:                                 ;            pty - index register Y
   63:                                 ; Description: First setup up the microcontroller setting up the clock, 
   64:                                 ;             shutting down the COP watchdog timer, and initialising 
   65:                                 ;             the SCI serial interface. Initialises global variables also.
   66:                                 ;------------------------------------------------------
   67:     202B                        inithw:
   68:                                 ; -- Initialise the hardware
   69:                                 ; Initialise the Phase-Lock-Loop (se page 34 of Dragon 12 Manual
   70:                                 ;       The crystal freq. on the DRAGON12 Plus board is 8 MHz so the default bus speed is 2 MHz
   71:                                 ;       In order to set the bus speed higher than 4 MHz the PLL must be initialized
   72:                                 ;
   73:                                 ;       The math used to set the PLL frequency is:
   74:                                 ;        
   75:                                 ;       PLLCLK = CrystalFreq * 2 * (initSYNR+1) / (initREFDV+1)
   76:                                 ;       
   77:                                 ;       If CrystalFreq = 8Mhz on DRAGON12 Plus board
   78:                                 ;         initSYNR     = 5    PLL multiplier will be 6
   79:                                 ;         initREFDV    = 0    PLL divisor will be 1
   80:                                 
   81:                                 ;       PLLCLK = 4*2*6/1 = 48MHz
   82:                                 ;       The bus speed = PLLCLK / 2 = 24 MHz
   83:                                 ;
   84:                                 ;      
   85:                                 ;********PLL code for 24MHz bus speed from a 4/8/16 crystal
   86:     202B 1410                           sei
   87:     202D CE 0000                        ldx #Regblk
   88:     2030 0D E0 39 80                    bclr Clksel,x,%10000000  ; clear bit 7, clock derived from oscclk
   89:     2034 0C E0 3A 40                    bset Pllctl,x,%01000000  ; Turn PLL on, bit 6 =1 PLL on, bit 6=0 PLL off
   90:     2038 86 05                          ldaa #$05                ; 5+1=6 multiplier 
   91:     203A 6A E0 34                       staa Synr,x
   92:                                 ;        ldaa #$03                ; divisor=3+1=4, 16 *6 /4 = 24Mhz for 16 MHz crystal
   93:     203D 86 01                          ldaa #$01                ; divisor=1+1=2,  8 *6 /2 = 24Mhz for  8 MHz crystal
   94:                                 ;        ldaa #$00                ; divisor=0+1=1,  4 *6 /1 = 24Mhz for  4 MHz crystal
   95:     203F 6A E0 35                       staa Refdv,x
   96:     2042                        wait_b3:
   97:     2042 0F E0 37 08 FB                 brclr Crgflg,x, %00001000 wait_b3  ; Wait until bit 3 = 1
   98:     2047 0C E0 39 80                    bset Clksel,x, %10000000
   99:                                 
  100:                                         ; Setup Serial port
  101:     204B CC 009C                        ldd #156
  102:     204E 5C C8                          std Sc0bdh   ; Sets up the baud rate
  103:     2050 86 0C                          ldaa #$0c
  104:     2052 5A CB                          staa Sc0cr2  ; Enables serial interface
  105:                                         
  106:                                         ; Setup the data in the RAM
  107:                                         ; For the Configuration Module
  108:     2054 1803 0000 3002                 movw #0,alarmCode
  109:     205A 1803 03E8 3000                 movw #1000,mult
  110:     2060 3D                             rts
  111:                                 
  112:                                    switch globalConst
  113:                                 
  114:                                 ;-------------------------------------------------------------------------
  115:                                 ; Data Structures
  116:                                 ; The following data is stored in EEPROM 
  117:                                 ; Following is data array used by testWin 
  118:                                 ;   int alarmCodes[NUMCODES] = { 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF }; 
  119:                                 ;------------------------------------------------------
  120:     2398 0000 FFFF FFFF         alarmCodes dc.w $0000, $FFFF, $FFFF, $FFFF, $FFFF  ; note this will be updated in ROM
           239E FFFF FFFF 
  121:                                 
  122:                                 ; Message strings
  123:     23A2 43 45 47 33 31 33      MENU     dc.b   "CEG3136 Alarm",NL,CR,"c-Config a-Arm",NL,CR,$00
           23A8 36 20 41 6C 61 72 
           23AE 6D 0A 0D 63 2D 43 
           23B4 6F 6E 66 69 67 20 
           23BA 61 2D 41 72 6D 0A 
           23C0 0D 00 
  124:     23C2 0A 0D 00               NEWLINE  dc.b   NL,CR,$00
  125:                                 
  126:                                  
  127:                                 ;----------
  128:                                 ; Include other modules here
  129:                                 ;-----------
  130:                                  INCLUDE        config.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: config.asm - the CONFIGURATION Module
    4:                                 ; Author: Gilbert Arbez
    5:                                 ; Date: Fall 2010
    6:                                 ;------------------------------------------------------
    7:                                 
    8:                                         SWITCH code_section ; include in the code
    9:                                 ;-----------------------------------
   10:                                 ; Subroutine - configCodes
   11:                                 ; Parameters: none
   12:                                 ; Returns: nothing
   13:                                 ; Local Variables:   ix,  input, flag - on stack
   14:                                 ; Description: Gets user to select alarm code to update/disable. Calls
   15:                                 ;              setcode to update the alarm code.
   16:                                 ;------------------------------------------------------
   17:                                 ; Stack Usage
   18:                                         OFFSET 0 ; to setup offsets into stack
   19:     0000 +0001                  CFG_IX   DS.B 1   ; ix
   20:     0001 +0001                  CFG_INPUT DS.B 1  ; input
   21:     0002 +0001                  CFG_FLAG DS.B 1   ; flag
   22:     0003                        CFG_VARSIZE:
   23:     0003 +0002                  CFB_PR_D        DS.W 1  ; preserve D 
   24:     0005 +0002                  CFG_RA  DS.W 1  ; return address
   25:                                 
   26:     2061 3B                     configCodes: pshd
   27:                                       ; byte ix;  // index into array
   28:                                       ; byte input; // input from user.
   29:                                       ; byte flag;
   30:     2062 1B 9D                        leas -CFG_VARSIZE,SP
   31:     2064 16 20A7                cfg_if1: jsr enterMstCode ; if(enterMstCode())
   32:     2067 97                           tsta
   33:     2068 27 39                        beq cfg_endif1
   34:     206A                        cfg_loop:               ;     do {
   35:     206A CC 23D3                      ldd #CONFIGMSG    ;          printf(CONFIGMSG);
   36:     206D 15 FB CE17                   jsr [printf,PCr]
   37:     2071 17 00                        jsr readKey ;          input = readKey();
   38:     2073 6B 81                        stab CFG_INPUT,SP ;
   39:     2075 1808 82 01                   movb #TRUE,CFG_FLAG,SP;      flag = TRUE;
   40:     2079                        cfg_if2:
   41:     2079 A6 81                        ldaa CFG_INPUT,SP ;          if(input == 'a')
   42:     207B 81 61                        cmpa #'a'
   43:     207D 26 07                        bne cfg_elseif2
   44:     207F 86 00                        ldaa #0           ;               setcode(0);
   45:     2081 16 2105                      jsr setcode
   46:     2084 20 19                        bra cfg_endif2
   47:     2086                        cfg_elseif2:
   48:     2086 81 31                        cmpa #'1'         ;           else if( input>='1' && input <= '4')
   49:     2088 25 0A                        blo cfg_else2
   50:     208A 81 34                        cmpa #'4'
   51:     208C 22 06                        bhi cfg_else2
   52:     208E 80 30                        suba #ASCII_CONV_NUM  ;       {   ix = input-ASCII_CONV_NUM;
   53:     2090 07 73                        bsr setcode           ;           setcode(ix); }
   54:     2092 20 0B                        bra cfg_endif2
   55:     2094                        cfg_else2:              ;           else      
   56:     2094 CC 23E6                      ldd #CERRMSG      ;           { printf(CERRMSG);
   57:     2097 15 FB CDED                   jsr [printf,PCr]  ;
   58:     209B 1808 82 00                   movb #FALSE,CFG_FLAG,SP ;       flag = FALSE; }
   59:     209F                        cfg_endif2:
   60:     209F E7 82                        tst CFG_FLAG,SP   ;       } while(!flag);
   61:     20A1 27 C7                        beq cfg_loop
   62:     20A3                        cfg_endif1:
   63:     20A3 1B 83                        leas CFG_VARSIZE,SP
   64:     20A5 3A                           puld
   65:     20A6 3D                           rts
   66:                                 
   67:                                 ;--------------------------------
   68:                                 ; Subroutine: enterMstCode
   69:                                 ; Parameters: none
   70:                                 ; Returns: TRUE - valid code entered, FALSE otherwise - Acc A.
   71:                                 ; Description: Prompts user for the 4 digit master alarm code.
   72:                                 ;-------------------------------
   73:                                 ; Stack Usage
   74:                                         OFFSET 0 ; to setup offsets into stack
   75:     0000 +0001                  EMC_RETVAL  DS.B 1   ; retval
   76:     0001 +0001                  EMC_I       DS.B 1   ; i
   77:     0002 +0001                  EMC_INPUT   DS.B 1   ; input
   78:     0003 +0002                  EMC_ALARMCODE DS.W 1 ; alarmCode
   79:     0005 +0002                  EMC_MULT    DS.W 1   ; mult
   80:     0007                        EMC_VARSIZE:
   81:     0007 +0002                  EMC_PR_Y    DS.W 1   ; preserve Y
   82:     0009 +0002                  EMC_PR_X    DS.W 1   ; preserve X
   83:     000B +0001                  EMC_PR_B    DS.B 1   ; preserve B
   84:     000C +0002                  EMC_RA      DS.W 1   ; return address
   85:                                 
   86:     20A7 37                     enterMstCode pshb
   87:     20A8 34                        pshx
   88:     20A9 35                        pshy
   89:     20AA 1B 99                     leas -EMC_VARSIZE,SP
   90:     20AC 1808 80 00                movb #FALSE,EMC_RETVAL,SP  ; byte retval = FALSE;
   91:                                                               ; byte i;
   92:                                                               ; byte input;
   93:     20B0 1800 83 0000              movw #0,EMC_ALARMCODE,SP   ; int alarmCode = 0;
   94:     20B5 1800 85 03E8              movw #1000,EMC_MULT,SP     ; int mult = 1000;
   95:                                    
   96:     20BA CC 23C5                   ldd #MSTCDMSG              ; printf(MSTCDMSG);
   97:     20BD 15 FB CDC7                jsr [printf, PCr]
   98:     20C1 69 81                     clr EMC_I,SP
   99:     20C3                        emc_for:                      ; for(i=0 ; i<4 ; i++)
  100:     20C3 17 00                     jsr readKey                ; {
  101:     20C5 6B 82                     stab EMC_INPUT,SP          ;    input = readKey();
  102:     20C7                        emc_if1:
  103:     20C7 180F                      tba
  104:     20C9 16 236A                   jsr isdigit                ;    if(!isdigit(input))
  105:     20CC 97                        tsta
  106:     20CD 27 2E                     beq emc_endfor             ;         break;
  107:     20CF                        emc_else1:                    ;    else {
  108:     20CF E6 82                     ldab EMC_INPUT,SP          ;       alarmCode = alarmCode + mult*(input-ASCII_CONV_NUM);
  109:     20D1 C0 30                     subb #ASCII_CONV_NUM
  110:     20D3 87                        clra
  111:     20D4 ED 85                     ldy  EMC_MULT,SP
  112:     20D6 13                        emul
  113:     20D7 E3 83                     addd EMC_ALARMCODE,SP
  114:     20D9 6C 83                     std EMC_ALARMCODE,SP
  115:     20DB EC 85                     ldd EMC_MULT,SP            ;       mult = mult/10;
  116:     20DD CE 000A                   ldx #10
  117:     20E0 1810                      idiv
  118:     20E2 6E 85                     stx EMC_MULT,SP
  119:     20E4 8E 0000                emc_if2: cpx #0               ;       if(mult == 0)  {
  120:     20E7 26 0B                     bne emc_endif2
  121:     20E9 FC 2398                emc_if3: ldd alarmCodes      ;            if(alarmCode == alarmCodes[0]) 
  122:     20EC AC 83                     cpd EMC_ALARMCODE,SP
  123:     20EE 26 04                     bne emc_endif3
  124:     20F0 1808 80 01                movb #TRUE,EMC_RETVAL,SP   ;                 retval = TRUE;
  125:     20F4                        emc_endif3:
  126:     20F4                        emc_endif2:                   ;       }
  127:     20F4                        emc_endif1:                   ;    }
  128:     20F4 A6 81                     ldaa EMC_I,SP
  129:     20F6 42                        inca
  130:     20F7 6A 81                     staa EMC_I,SP
  131:     20F9 81 04                     cmpa #4
  132:     20FB 25 C6                     blo emc_for
  133:     20FD                        emc_endfor:                   ; }
  134:     20FD A6 80                     ldaa EMC_RETVAL,SP         ; return(retval);
  135:     20FF 1B 87                     leas EMC_VARSIZE,SP
  136:     2101 31                        puly
  137:     2102 30                        pulx
  138:     2103 33                        pulb
  139:     2104 3D                        rts
  140:                                 
  141:                                 ;---------------------------------
  142:                                 ; Subroutine; setcode (ix)
  143:                                 ; Parameters
  144:                                 ;        ix - in accumulator a
  145:                                 ; Local variables
  146:                                 ;        flag, i, input, digit, alarmCode, mult - on stack
  147:                                 ; Description: Prompts user for a 4 digit alarm code to
  148:                                 ;              update the alarm code at index ix. If 'd'
  149:                                 ;              is entered the alarm code is disabled.  It
  150:                                 ;              is not allowed to diable the master
  151:                                 ;              alarm code.void setcode(byte ix).
  152:                                 ;------------------------------------------------------
  153:                                 ; Stack Usage
  154:                                         OFFSET 0 ; to setup offsets into stack
  155:     0000 +0001                  SETC_IX   DS.B 1  ; ix
  156:     0001 +0001                  SETC_FLAG DS.B 1  ; flag
  157:     0002 +0001                  SETC_I    DS.B 1  ; i
  158:     0003 +0001                  SETC_INPUT DS.B 1 ; input 
  159:     0004 +0002                  SETC_DIGIT DS.W 1 ; digit
  160:     0006 +0002                  SETC_ALARMCODE DS.W 1  ; alarmCode
  161:     0008 +0002                  SETC_MULT DS.W 1  ; mult
  162:     000A                        SETC_VARSIZE:
  163:     000A +0002                  SETC_PR_D DS.W 1        ; preserve D
  164:     000C +0002                  SETC_PR_X DS.W 1        ; preserve D 
  165:     000E +0002                  SETC_PR_Y DS.W 1        ; preserve D  
  166:     0010 +0002                  SETC_RA DS.W 1  ; return address
  167:                                 
  168:     2105 35                     setcode: pshy       ; {
  169:     2106 34                              pshx
  170:     2107 3B                              pshd
  171:     2108 1B 96                        leas -SETC_VARSIZE,SP   ; make room for variables
  172:     210A 180B 01 0001                 movb #TRUE, SETC_FLAG   ; byte flag = TRUE;
  173:                                                               ; byte i;
  174:                                                               ; byte input;
  175:                                                               ;int digit;
  176:     210F 1800 86 0000                 movw #0,SETC_ALARMCODE,SP   ; int alarmCode=0;
  177:     2114 1800 88 03E8                 movw #1000,SETC_MULT,SP ; int mult=1000; // multiplier
  178:     2119 6A 80                        staa SETC_IX,SP         ; save parameter value
  179:     211B                        setc_loop:                    ; do {
  180:     211B CC 23F2                      ldd #GET_CODE_MSG       ;      printf(GET_CODE_MSG);
  181:     211E 15 FB CD66                   jsr [printf, PCr]
  182:     2122 69 82                        clr SETC_I,SP           ;      for(i=0 ; i< 4 ; i++)
  183:     2124                        setc_for:                     ;      {
  184:     2124 17 00                        jsr readKey             ;         input = readKey();
  185:     2126 6B 83                        stab SETC_INPUT,SP
  186:     2128 C1 64                  setc_if cmpb #'d'             ;         if(input == 'd')
  187:     212A 26 1C                        bne setc_elseif         ;         { 
  188:     212C A6 80                  setc_if2 ldaa SETC_IX,SP      ;            if(ix == 0) 
  189:     212E 81 00                        cmpa #0
  190:     2130 26 09                        bne setc_else2
  191:     2132 CC 2400                      ldd #ERR_MST_MSG        ;               printf(ERR_MST_MSG);
  192:     2135 15 FB CD4F                   jsr [printf,PCr]
  193:     2139 20 0B                        bra setc_endif2
  194:     213B                        setc_else2                    ;            else {
  195:     213B 1800 86 FFFF                 movw #$ffff,SETC_ALARMCODE,SP ;            alarmCode = 0xffff;
  196:     2140 1808 81 00                   movb #FALSE,SETC_FLAG,SP;                  flag = FALSE;
  197:     2144 20 3E                        bra setc_endfor          ;                 break; 
  198:     2146                        setc_endif2                   ;             }
  199:     2146 20 33                        bra setc_endif          ;         }
  200:     2148                        setc_elseif:
  201:     2148 A6 83                        ldaa SETC_INPUT,SP      ;         else if(isdigit(input))
  202:     214A 16 236A                      jsr isdigit
  203:     214D 97                           tsta
  204:     214E 27 22                        beq setc_else
  205:     2150 E6 83                        ldab SETC_INPUT,SP      ;         {  digit = input - ASCII_CONV_NUM;
  206:     2152 C0 30                        subb #ASCII_CONV_NUM
  207:     2154 87                           clra
  208:     2155 6C 84                        std SETC_DIGIT,SP       ;            alarmCode = alarmCode + digit * mult;
  209:     2157 ED 88                        ldy SETC_MULT,SP
  210:     2159 13                           EMUL                    ; // Result digit*mult is in D
  211:     215A E3 86                        addd SETC_ALARMCODE,SP
  212:     215C 6C 86                        std SETC_ALARMCODE,SP
  213:     215E EC 88                        ldd SETC_MULT,SP        ;            mult = mult/10;
  214:     2160 CE 000A                      ldx #10
  215:     2163 1810                         idiv
  216:     2165 6E 88                        stx SETC_MULT,SP
  217:     2167 8E 0000                      cpx #0                  ;            if(mult == 0)
  218:     216A 26 0F                        bne setc_endif          ;             
  219:     216C 1808 81 00                   movb #FALSE,SETC_FLAG,SP ;                flag = FALSE;
  220:     2170 20 09                        bra setc_endif          ;         }
  221:     2172                        setc_else:                    ;         else {
  222:     2172 CC 23E6                      ldd #CERRMSG            ;                printf(CERRMSG);
  223:     2175 15 FB CD0F                   jsr [printf, PCr]
  224:     2179 20 09                        bra setc_endfor         ;                break;
  225:                                                               ;         }
  226:     217B                        setc_endif:
  227:     217B A6 82                        ldaa SETC_I,SP
  228:     217D 42                           inca
  229:     217E 6A 82                        staa SETC_I,SP
  230:     2180 81 04                        cmpa #4
  231:     2182 25 A0                        blo setc_for 
  232:     2184                        setc_endfor:                       ;   }
  233:     2184 E7 81                        tst SETC_FLAG,SP        ; } while(flag);
  234:     2186 26 93                        bne setc_loop
  235:     2188 A6 80                        lda SETC_IX,SP   ; writeToEE( (int) &alarmCodes[ix], alarmCode);
  236:     218A 48                           lsla  ; double index value - 2 bytes/element
  237:     218B CE 2398                      ldx #alarmCodes
  238:     218E 1A E4                        leax a,x
  239:     2190 EC 86                        ldd SETC_ALARMCODE,SP
  240:     2192 07 06                        bsr writeToEE
  241:     2194 1B 8A                        leas SETC_VARSIZE,SP    ; skip over variables
  242:     2196 3A                           puld                    ; restore registers
  243:     2197 30                           pulx
  244:     2198 31                           puly
  245:     2199 3D                           rts
  246:                                 ;---------------------------------
  247:                                 ; Subroutine: writeToEE()
  248:                                 ; Parameters: address - in x register
  249:                                 ;             alarmCode    - in d register
  250:                                 ; Variables: none
  251:                                 ; Description:
  252:                                 ;     Write the alarm code in EEProm. writeEEByte() is a 
  253:                                 ;     function avaible in Debug12.
  254:                                 ;------------------------------------------------------
  255:                                 ; Stack Usage
  256:                                         OFFSET 0 ; to setup offsets into stack
  257:     0000 +0002                  WREE_PR_D DS.W 1        ; preserve D - alarmCode
  258:     0002 +0002                  WREE_PR_X DS.W 1        ; preserve X - address 
  259:     0004 +0002                  WREE_RA DS.W 1  ; return address
  260:                                 
  261:     219A 34                     writeToEE:  pshx
  262:     219B 3B                                 pshd
  263:     219C E6 80                              ldab WREE_PR_D,SP   ;  writeEEByte(address, (byte)((alarmCode&0xff00)>>8) );
  264:     219E 3B                                 pshd   ; save argument on stack
  265:     219F B7 54                              tfr x,d ; first argument passed in D
  266:     21A1 4B FB CD01                         call [writeEEByte, PCr]
  267:     21A5 30                                 pulx  ; remove argument
  268:     21A6 EE 82                              ldx WREE_PR_X,SP     ; get address
  269:     21A8 E6 81                              ldab WREE_PR_D+1,SP  ; writeEEByte(address+1, (byte)(alarmCode&0xff) );
  270:     21AA 3B                                 pshd  ; save argument on stack
  271:     21AB B7 54                              tfr x,d ; first argument passed in D
  272:     21AD C3 0001                            addd #1 ; address+1
  273:     21B0 4B FB CCF2                         call [writeEEByte, PCr]
  274:     21B4 30                                 pulx   ; remove argument
  275:     21B5 3A                                 puld   ; restore D
  276:     21B6 30                                 pulx   ; restore X
  277:     21B7 3D                                 rts
  278:                                         
  279:                                    switch globalConst
  280:     23C5 4D 61 73 74 65 72      MSTCDMSG    dc.b "Master code",NL,CR,$00
           23CB 20 63 6F 64 65 0A 
           23D1 0D 00 
  281:     23D3 61 3A 6D 73 74 72      CONFIGMSG   dc.b "a:mstr 1-4:other",NL,CR,$00
           23D9 20 31 2D 34 3A 6F 
           23DF 74 68 65 72 0A 0D 
           23E5 00 
  282:     23E6 42 61 64 20 65 6E      CERRMSG     dc.b "Bad entry",NL,CR,$00
           23EC 74 72 79 0A 0D 00 
  283:     23F2 43 6F 64 65 20 6F      GET_CODE_MSG dc.b "Code or 'd'",NL,CR,$00
           23F8 72 20 27 64 27 0A 
           23FE 0D 00 
  284:     2400 43 61 6E 6E 6F 74      ERR_MST_MSG dc.b "Cannot disable",NL,CR,$00
           2406 20 64 69 73 61 62 
           240C 6C 65 0A 0D 00 
  285:                                 
  131:                                  INCLUDE        armed.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: armed.asm
    4:                                 ; Description: The Armed Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:          =00000BB8              ARMDELAY  equ 3000; 15000
   11:          =000003E8              BEEPDELAY equ 1000
   12:                                 
   13:                                 ;-------------------------------------------
   14:                                 ; Subroutine: enableAlarm
   15:                                 ; Parameters: none
   16:                                 ; Returns: nothing
   17:                                 ; Variables
   18:                                 ;       input, codeValid, delayFlag - on stack
   19:                                 ; Description:
   20:                                 ;     Gets user to enter a valid alarm code to arm
   21:                                 ;     the alarm system.  Delays 15 seconds (to allow user
   22:                                 ;     to leave; the alarm can be disarmed during this period),
   23:                                 ;     monitors for trigger events (a, b, c, d, e).  When 'a'
   24:                                 ;     is detected, 15 seconds are allowed to enter an alarm code to
   25:                                 ;     disarm the system; otherwise the alarm is triggered. For other
   26:                                 ;     trigger events, the alarm is triggered instantly.  The alarm
   27:                                 ;     system can be turned off after being triggered with an alarm
   28:                                 ;     code.
   29:                                 ;------------------------------------------------------
   30:                                 ; Stack Usage:
   31:                                         OFFSET 0  ; to setup offset into stack
   32:     0000 +0001                  EAL_INPUT      DS.B 1  ; input
   33:     0001 +0001                  EAL_CODEVALID  DS.B 1 ; codeValid
   34:     0002 +0001                  EAL_DELAYFLAG  DS.B 1 ; delayFlag
   35:     0003                        EAL_VARSIZE:
   36:     0003 +0002                  EAL_PR_D              DS.W 1 ; preserve D
   37:     0005 +0002                  EAL_RA         DS.W 1 ; return address
   38:                                 
   39:     21B8 3B                     enableAlarm:  pshd
   40:     21B9 1B 9D                     leas  -EAL_VARSIZE,SP        ;byte input;  // input from user
   41:                                                                 ;byte codeValid;  // valid alarm code found
   42:                                                                 ;byte delayFlag;
   43:                                    ;// Get a valid alarm code to arm the system
   44:     21BB CC 2411                   ldd #CODEMSG                 ; printf(CODEMSG);
   45:     21BE 15 FB CCC6                jsr [printf, PCr]
   46:     21C2 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   47:     21C6                        eal_while1:
   48:     21C6 E7 81                     tst EAL_CODEVALID,SP         ; while(!codeValid) 
   49:     21C8 26 0D                     bne eal_endwhile1            ; {
   50:     21CA 17 00                     jsr readKey                  ;   input = readKey();
   51:     21CC 6B 80                     stab EAL_INPUT,SP
   52:     21CE 180F                      tba
   53:     21D0 16 2297                   jsr checkCode                ;     codeValid = checkCode(input);
   54:     21D3 6A 81                     staa EAL_CODEVALID,SP
   55:     21D5 20 EF                     bra eal_while1
   56:     21D7                        eal_endwhile1                   ; }
   57:                                 
   58:     21D7 CC 2418                   ldd #ARMING                   ; printf(ARMING);
   59:     21DA 15 FB CCAA                jsr [printf,PCr]
   60:                                    ; // Delay 1500 ms, i.e. 15 seconds
   61:     21DE CC 0BB8                   ldd #ARMDELAY                 ; setDelay(ARMDELAY);
   62:     21E1 16 2362                   jsr setDelay
   63:     21E4 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   64:     21E8 1808 82 00                movb #FALSE,EAL_DELAYFLAG,SP ; delayFlag = FALSE;
   65:     21EC                        eal_while2:                     ; while(!delayFlag) 
   66:     21EC E7 82                     tst EAL_DELAYFLAG,SP         ; {
   67:     21EE 26 27                     bne eal_endwhile2
   68:     21F0 16 2363                   jsr polldelay                ;   delayFlag = delay(); 
   69:     21F3 6A 82                     staa EAL_DELAYFLAG,SP
   70:     21F5 17 00                     jsr pollreadKey              ;   input = pollreadKey();  // check if code entered to disarm
   71:     21F7 6B 80                     stab EAL_INPUT,SP
   72:     21F9 180F                      tba
   73:     21FB                        eal_if1:
   74:     21FB 81 23                     cmpa #'#'                    ;   if(isdigit(input) || input == '#') 
   75:     21FD 27 08                     beq eal_blk1
   76:     21FF 16 236A                   jsr isdigit
   77:     2202 97                        tsta
   78:     2203 26 02                     bne eal_blk1
   79:     2205 20 0E                     bra eal_endif1   
   80:     2207                        eal_blk1:                       ;    {
   81:     2207 A6 80                     ldaa EAL_INPUT,SP            
   82:     2209 16 2297                   jsr checkCode                ;        codeValid = checkCode(input);
   83:     220C 6A 81                     staa EAL_CODEVALID,SP
   84:     220E                        eal_if2:
   85:     220E 97                        tsta                         ;        if(codeValid) 
   86:     220F 27 04                     beq eal_endif2
   87:     2211 1808 82 01                movb #TRUE,EAL_DELAYFLAG,SP  ;            delayFlag = TRUE;  // break out of loop
   88:     2215                        eal_endif2:
   89:     2215                        eal_endif1:                     ;    }
   90:     2215 20 D5                     bra eal_while2               
   91:     2217                        eal_endwhile2                   ; }
   92:                                 
   93:                                    ;// Loop to monitor trigger events and alarm code to disable
   94:                                    ;// codeValid is TRUE if valid alarm code entered during delay
   95:     2217                        eal_if3:                        ; if(!codeValid)
   96:     2217 E7 81                     tst EAL_CODEVALID,SP
   97:     2219 26 07                     bne eal_endif3
   98:     221B CC 2429                   ldd #ARMED                   ;        printf(ARMED)
   99:     221E 15 FB CC66                jsr [printf, PCr]
  100:     2222                        eal_endif3:
  101:     2222                        eal_while3                      ;  while(!codeValid)
  102:     2222 E7 81                     tst EAL_CODEVALID,SP         ; {
  103:     2224 26 6D                     bne eal_endwhile3
  104:     2226 17 00                     jsr pollReadKey              ;    input = pollReadKey();
  105:     2228 6B 80                     stab EAL_INPUT,SP
  106:     222A 180F                      tba
  107:     222C                        eal_elseif
  108:     222C 81 23                     cmpa #'#'                    ;    if(isdigit(input) || input == '#') 
  109:     222E 27 08                     beq eal_blk2
  110:     2230 16 236A                   jsr isdigit
  111:     2233 97                        tsta
  112:     2234 26 02                     bne eal_blk2
  113:     2236 20 08                     bra eal_elseifA  
  114:     2238                        eal_blk2:      
  115:     2238 A6 80                     ldaa EAL_INPUT,SP             ;        codeValid = checkCode(input);
  116:     223A 07 5B                     bsr checkCode                
  117:     223C 6A 81                     staa EAL_CODEVALID,SP 
  118:     223E 20 51                     bra eal_endelseif    
  119:     2240                        eal_elseifA:
  120:     2240 16 2394                   jsr getSwStatus               ;   else if(getSwStatus() & 0b00000001) // Front door opened
  121:     2243 84 01                     anda #%00000001
  122:     2245 27 3C                     beq eal_elseifB               ;   {
  123:     2247 CC 2439                   ldd #DISARMING                ;      printf(DISARMING);
  124:     224A 15 FB CC3A                jsr [printf, PCr]
  125:     224E CC 0BB8                   ldd #ARMDELAY                 ;      setDelay(ARMDELAY);
  126:     2251 16 2362                   jsr setDelay
  127:     2254                        eal_while4:                      ;      while(!codeValid)
  128:     2254 A6 81                     ldaa EAL_CODEVALID,SP         ;      {
  129:     2256 26 29                     bne eal_endwhile4 
  130:     2258                        eal_if4:
  131:     2258 16 2363                   jsr pollDelay                 ;         if(pollDelay())
  132:     225B 97                        tsta  
  133:     225C 27 09                     beq eal_else4                 ;         { 
  134:     225E 16 2318                   jsr triggerAlarm              ;            triggerAlarm();
  135:     2261 1808 81 01                movb #TRUE,EAL_CODEVALID,SP   ;            codeValid = TRUE;           
  136:     2265 20 18                     bra eal_endif4                ;         }
  137:     2267                        eal_else4                        ;         else {
  138:     2267 17 00                     jsr pollReadKey               ;            input = pollReadKey();  // check if alarm code entered to disarm
  139:     2269 6B 80                     stab EAL_INPUT,SP
  140:     226B                        eal_if5:
  141:     226B 180F                      tba                           ;            if(isdigit(input) || input == '#')
  142:     226D 81 23                     cmpa #'#' 
  143:     226F 27 08                     beq eal_blk3
  144:     2271 16 236A                   jsr isdigit
  145:     2274 97                        tsta
  146:     2275 26 02                     bne eal_blk3
  147:     2277 20 06                     bra eal_endif5   
  148:     2279                        eal_blk3:  
  149:     2279 A6 80                     ldaa EAL_INPUT,SP
  150:     227B 07 1A                     bsr checkCode                ;                 codeValid = checkCode(input);
  151:     227D 6A 81                     staa EAL_CODEVALID,SP 
  152:     227F                        eal_endif5:
  153:     227F                        eal_endif4:                     ;          }
  154:     227F 20 D3                     bra eal_while4
  155:     2281                        eal_endwhile4:                  ;        }
  156:     2281                        eal_endelseifA                  ;      }
  157:     2281 20 0E                     bra eal_endelseif;      
  158:     2283                        eal_elseifB:
  159:     2283 16 2394                   jsr getSwStatus              ;      else if(getSwStatus() & 0b11111110) // other door/window opened
  160:     2286 84 FE                     anda #%11111110              ;      
  161:     2288 27 07                     beq eal_endelseifB           ;      {
  162:     228A 16 2318                   jsr triggerAlarm             ;          triggerAlarm();
  163:     228D 1808 81 01                movb #TRUE,EAL_CODEVALID,SP  ;          codeValid = TRUE;
  164:     2291                        eal_endelseifB:                 ;      }
  165:                                    ;    // ignore all other input
  166:     2291                        eal_endelseif:
  167:     2291 20 8F                      bra eal_while3
  168:     2293                        eal_endwhile3                   ; }
  169:     2293 1B 83                      leas EAL_VARSIZE,SP
  170:     2295 3A                         puld
  171:     2296 3D                         rts
  172:                                 
  173:                                 
  174:                                 ;------------------------------------------------------
  175:                                 ; Subroutine: checkCode
  176:                                 ; Parameters: input - accumulator A
  177:                                 ; Returns: TRUE when a valid alarm code is detected, FALSE otherwise - stored in 
  178:                                 ;          accumulator A
  179:                                 ; Local Variables: retval - on stack
  180:                                 ; Global Variables:
  181:                                 ;       mult - initilased to 1000 in inithw (Alarm System Module)
  182:                                 ;       alarmCode - initialised to 0 in inithw (Alarm System Module)
  183:                                 ; Descriptions: Creates alarm code using digits entered until
  184:                                 ;               4 digits are seen. After 4th digit, see if
  185:                                 ;               alarm code is valid using isCodeValid().
  186:                                 ;------------------------------------------------------
  187:                                 ; Stack usage
  188:                                         OFFSET 0
  189:     0000 +0001                  CKC_INPUT  DS.B 1 ; parameter input
  190:     0001 +0001                  CKC_RETVAL DS.B 1 ; variable retval
  191:     0002                        CKC_VARSIZE
  192:     0002 +0001                  CKC_PR_B          DS.B 1 ; preserve B
  193:     0003 +0002                  CKC_PR_X   DS.W 1 ; preserve X
  194:     0005 +0002                  CKC_PR_Y   DS.W 1 ; preserve Y
  195:     0007 +0002                  CKC_RA    DS.W 1 ; return address
  196:                                 
  197:     2297 35                     checkCode: pshy
  198:     2298 34                        pshx
  199:     2299 37                        pshb
  200:     229A 1B 9E                     leas -CKC_VARSIZE,SP       
  201:                                                               ; static int mult = 1000; // current multiplier of digit
  202:                                                               ; static int alarmCode = 0;   // alarm code value
  203:     229C 1808 81 00                movb #FALSE,CKC_RETVAL,SP  ; byte retval = FALSE;
  204:     22A0 6A 80                     staa CKC_INPUT,SP          ; save paramater value
  205:                                    
  206:     22A2 16 236A                   jsr isdigit                ; if(isdigit(input))
  207:     22A5 97                        tsta
  208:     22A6 27 36                     beq ckc_else               ; {
  209:     22A8 A6 80                     ldaa CKC_INPUT,SP          ;    alarmCode = alarmCode + (input-ASCII_CONV_NUM)*mult
  210:     22AA 80 30                     suba #ASCII_CONV_NUM
  211:     22AC 180E                      tab                        
  212:     22AE 87                        clra
  213:     22AF FD 3000                   ldy mult
  214:     22B2 13                        emul                       ; //*mult - result in D
  215:     22B3 F3 3002                   addd alarmCode
  216:     22B6 7C 3002                   std alarmCode
  217:     22B9 FC 3000                   ldd mult                   ;    mult = mult/10;
  218:     22BC CE 000A                   ldx #10
  219:     22BF 1810                      idiv
  220:     22C1 7E 3000                   stx mult
  221:     22C4 FC 3000                   ldd mult                   ;    if(mult == 0) 
  222:     22C7 26 13                     bne ckc_endif1             ;    {
  223:     22C9 FC 3002                   ldd alarmcode              ;
  224:     22CC 07 24                     bsr isCodeValid            ;       retval = isCodeValid(alarmCode);
  225:     22CE 6A 81                     staa CKC_RETVAL,SP
  226:     22D0 CC 0000                   ldd #0                     ;       alarmCode = 0;
  227:     22D3 7C 3002                   std alarmCode 
  228:     22D6 CC 03E8                   ldd #1000                  ;       mult = 1000;
  229:     22D9 7C 3000                   std mult     
  230:     22DC                        ckc_endif1:                   ;     }
  231:     22DC 20 0C                     bra ckc_endif              ; }
  232:     22DE                        ckc_else:                     ; else {
  233:     22DE CC 0000                   ldd #0                     ;       alarmCode = 0;
  234:     22E1 7C 3002                   std alarmCode 
  235:     22E4 CC 03E8                   ldd #1000                  ;       mult = 1000;
  236:     22E7 7C 3000                   std mult                   ; }
  237:     22EA                        ckc_endif:
  238:                                    
  239:     22EA A6 81                     ldaa CKC_RETVAL,SP         ; return(retval);
  240:                                    ; Restore registers and stack
  241:     22EC 1B 82                     leas CKC_VARSIZE,SP
  242:     22EE 33                        pulb
  243:     22EF 30                        pulx
  244:     22F0 31                        puly
  245:     22F1 3D                        rts      
  246:                                 
  247:                                 
  248:                                 ;------------------------------------------------------
  249:                                 ; Subroutine: isCodeValid
  250:                                 ; Parameters: alarmCode stored in register D
  251:                                 ; Local Variables
  252:                                 ;   ptr - pointer to array - in register X
  253:                                 ;   cnt, retval - on the stack.
  254:                                 ; Returns: TRUE/FALSE - Returned in accumulator A 
  255:                                 ; Description: Checks to see if alarm code is in the
  256:                                 ;              alarmCodes array.
  257:                                 ;------------------------------------------------------
  258:                                 
  259:                                 ; Stack usage
  260:                                         OFFSET 0
  261:     0000 +0002                  CDV_ALARMCODE   DS.W 1 ; alarmCode
  262:     0002 +0001                  CDV_CNT    DS.B 1 ; cnt
  263:     0003 +0001                  CDV_RETVAL DS.B 1 ; retval
  264:     0004                        CDV_VARSIZE:
  265:     0004 +0002                  CDV_PR_X   DS.W 1 ; preserve x register
  266:     0006 +0002                  CDV_RA     DS.W 1 ; return address
  267:                                 
  268:     22F2 34                     isCodeValid: pshx
  269:     22F3 1B 9C                     leas -CDV_VARSIZE,SP
  270:     22F5 6C 80                     std CDV_ALARMCODE,SP
  271:                                    ; int *ptr;  // pointer to alarmCodes
  272:     22F7 1808 82 05                movb #NUMCODES,CDV_CNT,SP ; byte cnt = 5;
  273:     22FB 1808 83 00                movb #FALSE,CDV_RETVAL,SP ; byte retval = FALSE;
  274:     22FF CE 2398                   ldx #alarmCodes           ; ptr = alarmCodes;
  275:     2302                        cdv_while                    ; do
  276:     2302 EC 31                     ldd 2,X+                  ; {
  277:     2304 AC 80                     cpd CDV_ALARMCODE,SP      ;    if(*ptr++ == alarmCode)
  278:     2306 26 06                     bne cdv_endif             ;    {
  279:     2308 1808 83 01                movb #TRUE,CDV_RETVAL,SP  ;      retval = TRUE;
  280:     230C 20 04                     bra cdv_endwhile          ;      break;
  281:     230E                        cdv_endif:                   ;    }
  282:     230E 63 82                     dec CDV_CNT,SP            ;   cnt--;
  283:     2310 26 F0                     bne cdv_while             ; } while(cnt != 0); 
  284:     2312                        cdv_endwhile:
  285:     2312 A6 83                     ldaa CDV_RETVAL,SP         ;   return(retval);
  286:                                    ; restore registers and stack
  287:     2314 1B 84                     leas CDV_VARSIZE,SP 
  288:     2316 30                        pulx
  289:     2317 3D                        rts
  290:                                 
  291:                                 ;----------------------------
  292:                                 ; Subroutine: triggerAlarm
  293:                                 ; Parameters: none
  294:                                 ; Returns: nothing
  295:                                 ; Local Variables: retval, dobel, input - on stack
  296:                                 ; Description: Repeatedly sends a bel character to the
  297:                                 ;              terminal until a valid alarm code is entered.
  298:                                 ;----------------------------
  299:                                 ; Stack usage
  300:                                         OFFSET 0
  301:     0000 +0002                  TRA_DONE   DS.W 1 ; done
  302:     0002 +0001                  TRA_DONEINPUT  DS.B 1 ; doneInput
  303:     0003 +0001                  TRA_INPUT  DS.B 1 ; input
  304:     0004                        TRA_VARSIZE:
  305:     0004 +0002                  TRA_PR_D   DS.W 1 ; preserve D register
  306:     0006 +0002                  TRA_RA     DS.W 1 ; return address
  307:                                 
  308:     2318 3B                     triggerAlarm: pshd
  309:     2319 1B 9C                     leas -TRA_VARSIZE,SP
  310:     231B 1808 80 00                movb #FALSE,TRA_DONE,SP   ; byte done = FALSE;
  311:                                                              ; byte dobel;
  312:                                                              ; byte input;
  313:     231F                        tra_while:                   ; while(!done)
  314:     231F E7 80                     tst TRA_DONE,SP         ; {
  315:     2321 26 37                     bne tra_endwhile
  316:     2323 C6 07                     ldb #BEL                  ;    putchar(BEL);
  317:     2325 87                        clra
  318:     2326 15 FB CB5C                jsr [putchar, PCr]
  319:     232A CC 03E8                   ldd #BEEPDELAY            ;    setDelay(BEEPDELAY);   // 1 sec between beeps
  320:     232D 16 2362                   jsr setDelay
  321:     2330 1808 82 00                movb #FALSE,TRA_DONEINPUT,SP ; doneInput = FALSE;
  322:     2334                        tra_while2:                  ;    while(!doneInput) 
  323:     2334 E7 82                     tst TRA_DONEINPUT,SP      ;    {
  324:     2336 26 20                     bne tra_endwhile2
  325:     2338 16 2363                   jsr polldelay             ;       doneInput = delay();
  326:     233B 6A 82                     staa TRA_DONEINPUT,SP
  327:     233D 17 00                     jsr pollReadKey           ;       input = pollReadKey();  // check if code entered to disarm
  328:     233F 6B 83                     stab TRA_INPUT,SP
  329:     2341 180F                      tba
  330:     2343 81 23                     cmpa #'#'                 ;       if(isdigit(input) || input == '#') 
  331:     2345 27 08                     beq tra_blk1
  332:     2347 16 236A                   jsr isdigit
  333:     234A 97                        tsta
  334:     234B 26 02                     bne tra_blk1
  335:     234D 20 07                     bra tra_endif   
  336:     234F                        tra_blk1:
  337:     234F A6 83                     ldaa TRA_INPUT,SP
  338:     2351 16 2297                   jsr checkCode             ;                done = checkCode(input);
  339:     2354 6A 80                     staa TRA_DONE,SP 
  340:     2356                        tra_endif: 
  341:     2356 20 DC                     bra tra_while2
  342:     2358                        tra_endwhile2                ;    }
  343:     2358 20 C5                     bra tra_while
  344:     235A                        tra_endwhile                 ; }
  345:     235A 1B 84                     leas TRA_VARSIZE,SP
  346:     235C 3A                        puld
  347:     235D 3D                        rts
  348:                                 
  349:                                 ;-------------------------------------------------------------------------
  350:                                 ; Data Structures
  351:                                 ;-------------------------------------------------------------------------
  352:                                         SWITCH globalConst
  353:                                 ; Message strings
  354:     2411 43 6F 64 65 0A 0D      CODEMSG dc.b  "Code",NL,CR,$00
           2417 00 
  355:     2418 2A 2A 2A 20 41 72      ARMING  dc.b  "*** Arming ***",NL,CR,$00
           241E 6D 69 6E 67 20 2A 
           2424 2A 2A 0A 0D 00 
  356:     2429 2A 2A 2A 20 41 72      ARMED   dc.b  "*** Armed ***",NL,CR,$00
           242F 6D 65 64 20 2A 2A 
           2435 2A 0A 0D 00 
  357:     2439 2D 2D 20 44 69 73      DISARMING dc.b  "-- Disarming --",NL,CR,$00
           243F 61 72 6D 69 6E 67 
           2445 20 2D 2D 0A 0D 00 
  358:                                 
  359:                                    switch globalVar
  360:     3000 03E8                   mult dc.w 1000
  361:     3002 0000                   alarmCode dc.w 0
  132:                                  INCLUDE keyPad.asm
    1:                                 ;----------------------------------------------------------------------
    2:                                 ; File: Keypad.asm
    3:                                 ; Author:
    4:                                 
    5:                                 ; Description:
    6:                                 ;  This contains the code for reading the
    7:                                 ;  16-key keypad attached to Port A
    8:                                 ;  See the schematic of the connection in the
    9:                                 ;  design document.
   10:                                 ;
   11:                                 ;  The following subroutines are provided by the module
   12:                                 ;
   13:                                 ; char pollReadKey(): to poll keypad for a keypress
   14:                                 ;                 Checks keypad for 2 ms for a keypress, and
   15:                                 ;                 returns NOKEY if no keypress is found, otherwise
   16:                                 ;                 the value returned will correspond to the
   17:                                 ;                 ASCII code for the key, i.e. 0-9, *, # and A-D
   18:                                 ; void initkey(): Initialises Port A for the keypad
   19:                                 ;
   20:                                 ; char readKey(): to read the key on the keypad
   21:                                 ;                 The value returned will correspond to the
   22:                                 ;                 ASCII code for the key, i.e. 0-9, *, # and A-D
   23:                                 ;---------------------------------------------------------------------
   24:                                 
   25:                                 ; Include header files
   26:                                  include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
   27:                                  include "reg9s12.inc"  ; Defines EQU's for Peripheral Ports
    1:                                 *
    2:                                 *
    3:                                 *  HC12 i/o register locations (9s12dp256)
    4:                                 *
    5:                                 
    6:                                         ifndef REG9S12  ; include only if not yet included
  485:                                         endif   ; end of conditional assembly
   28:                                 
   29:                                 **************EQUATES**********
   30:                                 
   31:                                 
   32:                                 ;-----Conversion table
   33:          =00000010              NUMKEYS EQU     16      ; Number of keys on the keypad
   34:          =000000FF              BADCODE         EQU     $FF     ; returned of translation is unsuccessful
   35:          =00000000              NOKEY           EQU     $00   ; No key pressed during poll period
   36:          =00000001              POLLCOUNT       EQU     1     ; Number of loops to create 1 ms poll time
   37:                                 
   38:                                  SWITCH globalConst  ; Constant data
   39:                                 
   40:                                 
   41:                                 
   42:                                  SWITCH code_section  ; place in code section
   43:                                 ;-----------------------------------------------------------    
   44:                                 ; Subroutine: initKeyPad
   45:                                 ;
   46:                                 ; Description: 
   47:                                 ;       Initiliases PORT A
   48:                                 ;-----------------------------------------------------------    
   49:     235E                        initKeyPad:
   50:     235E 3D                             rts
   51:                                 
   52:                                 ;-----------------------------------------------------------    
   53:                                 ; Subroutine: ch <- pollReadKey
   54:                                 ; Parameters: none
   55:                                 ; Local variable:
   56:                                 ; Returns
   57:                                 ;       ch: NOKEY when no key pressed,
   58:                                 ;       otherwise, ASCII Code in accumulator B
   59:                                 
   60:                                 ; Description:
   61:                                 ;  Loops for a period of 2ms, checking to see if
   62:                                 ;  key is pressed. Calls readKey to read key if keypress 
   63:                                 ;  detected (and debounced) on Port A and get ASCII code for
   64:                                 ;  key pressed.
   65:                                 ;-----------------------------------------------------------
   66:                                 ; Stack Usage
   67:                                         OFFSET 0  ; to setup offset into stack
   68:                                 
   69:     0000                        pollReadKey: 
   70:                                 
   71:     235F 3D                        rts
   72:                                 
   73:                                 ;-----------------------------------------------------------    
   74:                                 ; Subroutine: ch <- readKey
   75:                                 ; Arguments: none
   76:                                 ; Local variable: 
   77:                                 ;       ch - ASCII Code in accumulator B
   78:                                 
   79:                                 ; Description:
   80:                                 ;  Main subroutine that reads a code from the
   81:                                 ;  keyboard using the subroutine readKeybrd.  The
   82:                                 ;  code is then translated with the subroutine
   83:                                 ;  translate to get the corresponding ASCII code.
   84:                                 ;-----------------------------------------------------------    
   85:                                 ; Stack Usage
   86:                                         OFFSET 0  ; to setup offset into stack
   87:                                 
   88:     0000                        readKey:
   89:                                 
   90:     2360 3D                         rts                    ;  return(ch); 
   91:                                 
   92:                                 
  133:                                  INCLUDE        delay.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Simulation Assembler Program
    3:                                 ; File: delay.asm
    4:                                 ; Description: The Delay Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                 ; Some definitions
   10:                                 
   11:                                         SWITCH code_section
   12:                                 
   13:                                 ;-------------------------------
   14:                                 ; Subroutine delayms
   15:                                 ; Parameters: num - number of milliseconds to delay - in D
   16:                                 ; Returns: nothing
   17:                                 ; Description: Delays for num ms. 
   18:                                 ;--------------------------------
   19:     2361                        delayms: 
   20:                                       ; Complete this routine, it shall be called from the Keypad Module
   21:     2361 3D                        rts
   22:                                 
   23:                                 ;------------------------------------------------------
   24:                                 ; Subroutine setDelay
   25:                                 ; Parameters: cnt - accumulator D
   26:                                 ; Returns: nothing
   27:                                 ; Global Variables: delayCount
   28:                                 ; Description: Intialises the delayCount 
   29:                                 ;              variable.
   30:                                 ;------------------------------------------------------
   31:     2362                        setDelay: 
   32:                                 
   33:                                    ; Use the subroutine developed in lab 1
   34:                                 
   35:     2362 3D                        rts
   36:                                 
   37:                                 
   38:                                 ;------------------------------------------------------
   39:                                 ; Subroutine: polldelay
   40:                                 ; Parameters:  none
   41:                                 ; Returns: TRUE when delay counter reaches 0 - in accumulator A
   42:                                 ; Local Variables
   43:                                 ;   retval - acc A cntr - X register
   44:                                 ; Global Variables:
   45:                                 ;      delayCount
   46:                                 ; Description: The subroutine delays for 1 ms, decrements delayCount.
   47:                                 ;              If delayCount is zero, return TRUE; FALSE otherwise.
   48:                                 ;   Core Clock is set to 24 MHz, so 1 cycle is 41 2/3 ns
   49:                                 ;   NOP takes up 1 cycle, thus 41 2/3 ns
   50:                                 ;   Need 24 cyles to create 1 microsecond delay
   51:                                 ;   8 cycles creates a 333 1/3 nano delay
   52:                                 ;       DEX - 1 cycle
   53:                                 ;       BNE - 3 cyles - when branch is taken
   54:                                 ;       Need 4 NOP
   55:                                 ;   Run Loop 3000 times to create a 1 ms delay   
   56:                                 ;------------------------------------------------------
   57:                                 ; Stack Usage:
   58:                                         OFFSET 0  ; to setup offset into stack
   59:     0000                        PDLY_VARSIZE:
   60:     0000 +0002                  PDLY_PR_Y   DS.W 1 ; preserve Y
   61:     0002 +0002                  PDLY_PR_X   DS.W 1 ; preserve X
   62:     0004 +0001                  PDLY_PR_B   DS.B 1 ; preserve B
   63:     0005 +0002                  PDLY_RA     DS.W 1 ; return address
   64:                                 
   65:     2363 37                     polldelay: pshb
   66:     2364 34                        pshx
   67:     2365 35                        pshy
   68:                                 
   69:                                 
   70:                                         ; Use the subroutine developed in lab 1
   71:                                 
   72:                                 
   73:                                 
   74:                                    ; restore registers and stack
   75:     2366 31                        puly
   76:     2367 30                        pulx
   77:     2368 33                        pulb
   78:     2369 3D                        rts
   79:                                 
   80:                                 
   81:                                 
   82:                                 ;------------------------------------------------------
   83:                                 ; Global variables
   84:                                 ;------------------------------------------------------
   85:                                    switch globalVar
   86:     3004 +0002                  delayCount ds.w 1   ; 2 byte delay counter
  134:                                  INCLUDE        utilities.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: utilities.asm
    4:                                 ; Description: The Utilities Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:                                 
   11:                                 ;------------------------------------------------------
   12:                                 ; Subroutine isdigit
   13:                                 ; Parameters: chr - received in accumulator A/moved to B 
   14:                                 ; Returns: TRUE - chr is a digit, FALSE otherwise
   15:                                 ; Variables: retval in accumulator A
   16:                                 ; Description: Returns TRUE if chr is a digit character
   17:                                 ;              and FALSE otherwise.
   18:                                 ;------------------------------------------------------
   19:     236A 37                     isdigit: pshb   ; save B on stack
   20:     236B 180E                      tab          ; save Parameter in B
   21:     236D 86 00                     ldaa #FALSE  ;   byte retval = FALSE;
   22:     236F C1 30                     cmpb #'0'    ;   if(chr >= '0' && chr <= '9') retval = TRUE;
   23:     2371 25 06                     blo ISD_endif
   24:     2373 C1 39                     cmpb #'9'
   25:     2375 22 02                     bhi ISD_endif
   26:     2377 86 01                     ldaa #TRUE
   27:     2379                        ISD_endif:
   28:     2379 33                        pulb         ; restore B
   29:     237A 3D                        rts          ; return(retval); // in A
   30:                                 
   31:                                 
   32:                                 
   33:                                 ;------------------------------------------------------
   34:                                 ; Subroutine: pollgetchar
   35:                                 ; Parameters:  none
   36:                                 ; Returns: char read from SC0 or NOCHAR if none available
   37:                                 ;          Returned in Acc A
   38:                                 ; Variables:
   39:                                 ;      ptr in X register
   40:                                 ;      sum in Accumulator B       
   41:                                 ; Description: Checks the RDRF bit to see if a character
   42:                                 ;              is available before reading a character using getchar.
   43:                                 ;------------------------------------------------------
   44:                                 
   45:     237B 36                     polgetchar: psha     ; gechar destroys contents of acc A
   46:     237C C6 FF                    ldab #NOCHAR        ;  char chr = NOCHAR;
   47:                                   
   48:     237E 4F CC 20 04              brclr sc0sr1,%00100000,PGC_endif ; if(SCI0SR1_RDRF==1) 
   49:     2382 15 FB CAFE               jsr [getchar, PCr]  ;                    chr = getchar();
   50:     2386                        PGC_endif
   51:     2386 32                        pula            ; restore registers
   52:     2387 3D                        rts             ; return(chr);  in ACC B
  135:                                  INCLUDE switches.asm
    1:                                 ;-------------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File:  switches.asm
    4:                                 ; Description: This file contains the Switches module for the
    5:                                 ;              Alarm System project.
    6:                                 ;-----------------------------------------------------------------*/
    7:                                 ; Include header files
    8:                                  include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
    9:                                  include "reg9s12.inc"  ; Defines EQU's for Peripheral Ports
    1:                                 *
    2:                                 *
    3:                                 *  HC12 i/o register locations (9s12dp256)
    4:                                 *
    5:                                 
    6:                                         ifndef REG9S12  ; include only if not yet included
  485:                                         endif   ; end of conditional assembly
   10:                                 
   11:                                  SWITCH code_section  ; place in code section
   12:                                 ;----------------------------------------
   13:                                 ; Subroutine: initSwitches
   14:                                 ; Parameters: none
   15:                                 ; Returns: nothing
   16:                                 ; Description: Initialises the port for monitoring the switches
   17:                                 ;              and controlling LEDs.
   18:                                 ;----------------------------------------
   19:     2388                        initSwitches:        
   20:     2388 79 0262                   clr  DDRH         ; DDRH = 0; // set to input (switches)
   21:     238B 180B FF 0264              movb #$ff,PERH     ; PERH = 0xff; // Enable pull-up/pull-down 
   22:     2390 79 0265                   clr  PPSH     ; PPSH = 0x00; // pull-up device connected to H
   23:                                                      ;             // switches ground the pins when closed.
   24:     2393 3D                        rts
   25:                                 
   26:                                 ;------------------------
   27:                                 ; Subrooutine: getSwStatus
   28:                                 ; Parameters:  none
   29:                                 ; Returns: Acc A - An 8 bit code that indicates which
   30:                                 ;          switches are opened (bit set to 1).
   31:                                 ; Description: Checks status of switches and 
   32:                                 ;              returns bytes that shows their
   33:                                 ;              status.      
   34:                                 ;---------------------------
   35:     2394                        getSwStatus:
   36:     2394 B6 0260                    ldaa PTH   ;return(PTH);
   37:     2397 3D                         rts
  136:                                 
  137:                                    switch code_section
  138:     2398                        ENDCODE ;  used to define where the dataEEPROM section starts
  139:                                         end                ; end of program

Symbols:
alarmcode                       *00003002
alarmcodes                      *00002398
armdelay                        *00000bb8
armed                           *00002429
arming                          *00002418
ascii_conv_num                  *00000030
beepdelay                       *000003e8
bel                             *00000007
cdv_alarmcode                   *00000000
cdv_cnt                         *00000002
cdv_endif                       *0000230e
cdv_endwhile                    *00002312
cdv_retval                      *00000003
cdv_varsize                     *00000004
cdv_while                       *00002302
cerrmsg                         *000023e6
cfg_else2                       *00002094
cfg_elseif2                     *00002086
cfg_endif1                      *000020a3
cfg_endif2                      *0000209f
cfg_flag                        *00000002
cfg_input                       *00000001
cfg_loop                        *0000206a
cfg_varsize                     *00000003
checkcode                       *00002297
ckc_else                        *000022de
ckc_endif                       *000022ea
ckc_endif1                      *000022dc
ckc_input                       *00000000
ckc_retval                      *00000001
ckc_varsize                     *00000002
clksel                          *00000039
codemsg                         *00002411
configcodes                     *00002061
configmsg                       *000023d3
cr                              *0000000d
crgflg                          *00000037
ddrh                            *00000262
disarming                       *00002439
eal_blk1                        *00002207
eal_blk2                        *00002238
eal_blk3                        *00002279
eal_codevalid                   *00000001
eal_delayflag                   *00000002
eal_else4                       *00002267
eal_elseifa                     *00002240
eal_elseifb                     *00002283
eal_endelseif                   *00002291
eal_endelseifb                  *00002291
eal_endif1                      *00002215
eal_endif2                      *00002215
eal_endif3                      *00002222
eal_endif4                      *0000227f
eal_endif5                      *0000227f
eal_endwhile1                   *000021d7
eal_endwhile2                   *00002217
eal_endwhile3                   *00002293
eal_endwhile4                   *00002281
eal_input                       *00000000
eal_varsize                     *00000003
eal_while1                      *000021c6
eal_while2                      *000021ec
eal_while3                      *00002222
eal_while4                      *00002254
emc_alarmcode                   *00000003
emc_endfor                      *000020fd
emc_endif2                      *000020f4
emc_endif3                      *000020f4
emc_for                         *000020c3
emc_i                           *00000001
emc_input                       *00000002
emc_mult                        *00000005
emc_retval                      *00000000
emc_varsize                     *00000007
enablealarm                     *000021b8
endcode                         *00002398
entermstcode                    *000020a7
err_mst_msg                     *00002400
false                           *00000000
get_code_msg                    *000023f2
getchar                         *0000ee84
getswstatus                     *00002394
inithw                          *0000202b
initkeypad                      *0000235e
initswitches                    *00002388
iscodevalid                     *000022f2
isd_endif                       *00002379
isdigit                         *0000236a
mainloop                        *0000200b
menu                            *000023a2
mnelse                          *00002028
mnelseif                        *0000201f
mnendif                         *00002028
mstcdmsg                        *000023c5
mult                            *00003000
nl                              *0000000a
nochar                          *000000ff
numcodes                        *00000005
perh                            *00000264
pgc_endif                       *00002386
pllctl                          *0000003a
polldelay                       *00002363
pollreadkey                     *00000000
ppsh                            *00000265
printf                          *0000ee88
program                         *00002000
pth                             *00000260
putchar                         *0000ee86
readkey                         *00000000
refdv                           *00000035
regblk                          *00000000
sc0bdh                          *000000c8
sc0cr2                          *000000cb
sc0sr1                          *000000cc
setc_alarmcode                  *00000006
setc_digit                      *00000004
setc_else                       *00002172
setc_else2                      *0000213b
setc_elseif                     *00002148
setc_endfor                     *00002184
setc_endif                      *0000217b
setc_endif2                     *00002146
setc_flag                       *00000001
setc_for                        *00002124
setc_i                          *00000002
setc_input                      *00000003
setc_ix                         *00000000
setc_loop                       *0000211b
setc_mult                       *00000008
setc_varsize                    *0000000a
setcode                         *00002105
setdelay                        *00002362
stack                           *00002000
synr                            *00000034
tra_blk1                        *0000234f
tra_done                        *00000000
tra_doneinput                   *00000002
tra_endif                       *00002356
tra_endwhile                    *0000235a
tra_endwhile2                   *00002358
tra_input                       *00000003
tra_varsize                     *00000004
tra_while                       *0000231f
tra_while2                      *00002334
triggeralarm                    *00002318
true                            *00000001
variables                       *00003000
wait_b3                         *00002042
wree_pr_d                       *00000000
wree_pr_x                       *00000002
writeeebyte                     *0000eea6
writetoee                       *0000219a

