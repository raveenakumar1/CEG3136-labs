C:\Users\Lenovo\Desktop\AlarmAssembler\keyPad.lst - generated by MGTEK Assembler ASM12 V1.26 Build 144 for WIN32 (x86) - Mon Sep 30 08:59:52 2024

    1:                                 ;------------------------------------------------------
    2:                                 ; File: Keypad.asm
    3:                                 ; Author: Will Wu
    4:                                 ; 
    5:                                 ; Description: Reads one of the 16 characters from the 
    6:                                 ;              keypad attached to Port A.
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                 ; Include files
   10:                                 #include "sections.inc" ; Contains the EQUATES for the symbols
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
    9:          =00000001              SECTIONS_DEFINED   EQU  1        ; prevents future inclusion of the file
   10:                                 
   11:                                 ; Define addresses of various sections
   12:          =00003000              VARIABLES EQU $3000   ; $3000 - $3FFF
   13:          =00002000              PROGRAM   EQU $2000  ; $2000 - $2FFF
   14:          =00002000              STACK     EQU $2000  ; $1000 - $1FFF
   15:                                 
   16:                                 ;----------------------------------------
   17:                                 ; Global Variable section
   18:                                 ; Use the DS - define storage directive
   19:                                 ;              to define space for 
   20:                                 ;              global variables and data
   21:                                 ;              structures.
   22:                                 ;----------------------------------------
   23:                                 globalVar SECTION
   24:          =00003000                      ORG VARIABLES   ; places section in RAM
   25:                                 ;-----------------------------------------
   26:                                 ; Code section
   27:                                 ; Enter assembly instructions (HCS12) to create
   28:                                 ; executable code.
   29:                                 ;-----------------------------------------
   30:                                 code_section SECTION
   31:          =00002000                      ORG PROGRAM  ; places section in RAM - simulates ROM
   32:                                 
   33:                                 ;------------------------------------------
   34:                                 ; Global constants
   35:                                 ; In simple programs (single module) global constants are 
   36:                                 ; simply placed at the end of code and not section is
   37:                                 ; explicitly defined.
   38:                                 ;--------------------------------------------
   39:                                 globalConst SECTION
sections.inc(40): Error A2038: col(13) 'endcode': undefined symbol
   40:                                         ORG ENDCODE ;--ENDCODE is defined on the second pass of the assembler
   41:                                 
   42:                                 ;----------------------------------------------
   43:                                 ; Defining the start of the globalConst Section
   44:                                 ; The following should be added to the end of the 
   45:                                 ; main module
   46:                                 ;----------------------------------------------
   47:                                 ;       SWITCH code_section 
   48:                                 ;ENDCODE        
   49:                                 
   50:                                          ENDIF  ; End of conditional assembly
   11:                                 #include "reg9s12.inc" ; Defines the EQUATES for the peripheral ports
    1:                                 *
    2:                                 *
    3:                                 *  HC12 i/o register locations (9s12dp256)
    4:                                 *
    5:                                 
    6:                                         ifndef REG9S12  ; include only if not yet included
    7:                                 
    8:          =00000001              REG9S12 EQU 1   ; for testing inclusion of this file
    9:                                 *
   10:          =00000000              Porta:          equ 0   ;port a = address lines a8 - a15
   11:          =00000001              Portb:          equ 1   ;port b = address lines a0 - a7
   12:          =00000002              Ddra:           equ 2   ;port a direction register
   13:          =00000003              Ddrb:           equ 3   ;port a direction register
   14:                                 
   15:          =00000008              Porte:          equ 8   ;port e = mode,irqandcontrolsignals
   16:          =00000009              Ddre:           equ 9   ;port e direction register
   17:          =0000000A              Pear:           equ $a  ;port e assignments
   18:          =0000000B              Mode:           equ $b  ;mode register
   19:          =0000000C              Pucr:           equ $c  ;port pull-up control register
   20:          =0000000D              Rdriv:          equ $d  ;port reduced drive control register
   21:          =0000000E              Ebictl:         equ $e  ;e stretch control
   22:                                 
   23:          =00000010              Initrm:         equ $10 ;ram location register
   24:          =00000011              Initrg:         equ $11 ;register location register
   25:          =00000012              Initee:         equ $12 ;eeprom location register
   26:          =00000013              Misc:           equ $13 ;miscellaneous mapping control
   27:          =00000014              Mtst0:          equ $14 ; reserved
   28:          =00000015              Itcr:           equ $15 ;interrupt test control register
   29:          =00000016              Itest:          equ $16 ;interrupt test register
   30:          =00000017              Mtst1:          equ $17 ; reserved
   31:                                 
   32:          =0000001A              Partidh:                equ $1a ;part id high
   33:          =0000001B              Partidl:                equ $1b ;part id low
   34:          =0000001C              Memsiz0:                equ $1c ;memory size
   35:          =0000001D              Memsiz1:                equ $1d ;memory size
   36:          =0000001E              Intcr:          equ $1e ;interrupt control register
   37:          =0000001F              Hprio:          equ $1f ;high priority reg
   38:                                 
   39:          =00000028              Bkpct0:         equ $28 ;break control register
   40:          =00000029              Bkpct1:         equ $29 ;break control register
   41:          =0000002A              Bkp0x:          equ $2a ; break 0 index register
   42:          =0000002B              Bkp0h:          equ $2b ; break 0 pointer high
   43:          =0000002C              Brp0l:          equ $2c ; break 0 pointer low
   44:          =0000002D              Bkp1x:          equ $2d ; break 1 index register
   45:          =0000002E              Bkp1h:          equ $2e ; break 1 pointer high
   46:          =0000002F              Brp1l:          equ $2f ; break 1 pointer low
   47:          =00000030              Ppage:          equ $30 ;program page register
   48:                                 
   49:          =00000032              Portk:          equ $32 ;port k data
   50:          =00000033              Ddrk:                   equ $33 ;port k direction
   51:          =00000034              Synr:           equ $34 ; synthesizer / multiplier register
   52:          =00000035              Refdv:          equ $35 ; reference divider register
   53:          =00000036              Ctflg:          equ $36 ; reserved
   54:          =00000037              Crgflg:         equ $37 ; pll flags register
   55:          =00000038              Crgint:         equ $38 ; pll interrupt register
   56:          =00000039              Clksel:         equ $39 ; clock select register
   57:          =0000003A              Pllctl:         equ $3a ; pll control register
   58:          =0000003B              Rtictl:         equ $3b ;real time interrupt control
   59:          =0000003C              Copctl:         equ $3c ;watchdog control
   60:          =0000003D              Forbyp:         equ $3d ;
   61:          =0000003E              Ctctl:          equ $3e ;
   62:          =0000003F              Armcop:         equ $3f ;cop reset register
   63:                                 
   64:          =00000040              Tios:           equ $40 ;timer input/output select
   65:          =00000041              Cforc:          equ $41 ;timer compare force
   66:          =00000042              Oc7m:           equ $42 ;timer output compare 7 mask
   67:          =00000043              Oc7d:           equ $43 ;timer output compare 7 data
   68:          =00000044              Tcnt:           equ $44 ;timer counter register hi
   69:                                 *Tcnt:          equ $45 ;timer counter register lo
   70:          =00000046              Tscr:           equ $46 ;timer system control register
   71:          =00000047              Ttov:           equ $47 ;reserved
   72:          =00000048              Tctl1:          equ $48 ;timer control register 1
   73:          =00000049              Tctl2:          equ $49 ;timer control register 2
   74:          =0000004A              Tctl3:          equ $4a ;timer control register 3
   75:          =0000004B              Tctl4:          equ $4b ;timer control register 4
   76:          =0000004C              Tmsk1:          equ $4c ;timer interrupt mask 1
   77:          =0000004D              Tmsk2:          equ $4d ;timer interrupt mask 2
   78:          =0000004E              Tflg1:          equ $4e ;timer flags 1
   79:          =0000004F              Tflg2:          equ $4f ;timer flags 2
   80:          =00000050              Tc0:            equ $50 ;timer capture/compare register 0
   81:          =00000052              Tc1:            equ $52 ;timer capture/compare register 1
   82:          =00000054              Tc2:            equ $54 ;timer capture/compare register 2
   83:          =00000056              Tc3:            equ $56 ;timer capture/compare register 3
   84:          =00000058              Tc4:            equ $58 ;timer capture/compare register 4
   85:          =0000005A              Tc5:            equ $5a ;timer capture/compare register 5
   86:          =0000005C              Tc6:            equ $5c ;timer capture/compare register 6
   87:          =0000005E              Tc7:            equ $5e ;timer capture/compare register 7
   88:          =00000060              Pactl:          equ $60 ;pulse accumulator controls
   89:          =00000061              Paflg:          equ $61 ;pulse accumulator flags
   90:          =00000062              Pacn3:          equ $62 ;pulse accumulator counter 3
   91:          =00000063              Pacn2:          equ $63 ;pulse accumulator counter 2
   92:          =00000064              Pacn1:          equ $64 ;pulse accumulator counter 1
   93:          =00000065              Pacn0:          equ $65 ;pulse accumulator counter 0
   94:          =00000066              Mcctl:          equ $66 ;modulus down conunter control
   95:          =00000067              Mcflg:          equ $67 ;down counter flags
   96:          =00000068              Icpar:          equ $68 ;input pulse accumulator control
   97:          =00000069              Dlyct:          equ $69 ;delay count to down counter
   98:          =0000006A              Icovw:          equ $6a ;input control overwrite register
   99:          =0000006B              Icsys:          equ $6b ;input control system control
  100:                                 
  101:          =0000006D              Timtst:         equ $6d ;timer test register
  102:                                 
  103:          =00000070              Pbctl:          equ $70 ; pulse accumulator b control
  104:          =00000071              Pbflg:          equ $71 ; pulse accumulator b flags
  105:          =00000072              Pa3h:           equ $72 ; pulse accumulator holding register 3
  106:          =00000073              Pa2h:           equ $73 ; pulse accumulator holding register 2
  107:          =00000074              Pa1h:           equ $74 ; pulse accumulator holding register 1
  108:          =00000075              Pa0h:           equ $75 ; pulse accumulator holding register 0
  109:          =00000076              Mccnt:          equ $76 ; modulus down counter register
  110:                                 *Mccntl:        equ $77 ; low byte
  111:          =00000078              Tcoh:           equ $78 ; capture 0 holding register
  112:          =0000007A              Tc1h:           equ $7a ; capture 1 holding register
  113:          =0000007C              Tc2h:           equ $7c ; capture 2 holding register
  114:          =0000007E              Tc3h:           equ $7e ; capture 3 holding register
  115:                                 
  116:          =00000080              Atd0ctl0:       equ $80 ;adc control 0 (reserved)
  117:          =00000081              Atd0ctl1:       equ $81 ;adc control 1 (reserved)
  118:          =00000082              Atd0ctl2:       equ $82 ;adc control 2
  119:          =00000083              Atd0ctl3:       equ $83 ;adc control 3
  120:          =00000084              Atd0ctl4:       equ $84 ;adc control 4
  121:          =00000085              Atd0ctl5:       equ $85 ;adc control 5
  122:          =00000086              Atd0stat:       equ $86 ;adc status register hi
  123:                                 *Atd0stat       equ $87 ;adc status register lo
  124:          =00000088              Atd0test:       equ $88 ;adc test (reserved)
  125:                                 *Atd0test       equ $89 ;
  126:                                 
  127:          =0000008D              Atd0dien:               equ $8d ;
  128:                                 
  129:          =0000008F              Portad0:         equ $8f ;port adc = input only
  130:          =00000090              Adr00h:         equ $90 ;adc result 0 register
  131:          =00000092              Adr01h:         equ $92 ;adc result 1 register
  132:          =00000094              Adr02h:         equ $94 ;adc result 2 register
  133:          =00000096              Adr03h:         equ $96 ;adc result 3 register
  134:          =00000098              Adr04h:         equ $98 ;adc result 4 register
  135:          =0000009A              Adr05h:         equ $9a ;adc result 5 register
  136:          =0000009C              Adr06h:         equ $9c ;adc result 6 register
  137:          =0000009E              Adr07h:         equ $9e ;adc result 7 register
  138:                                 
  139:          =000000A0              Pwme:                   equ $a0 ;pwm enable
  140:          =000000A1              Pwmpol:         equ $a1 ;pwm polarity
  141:          =000000A2              Pwmclk:         equ $a2 ;pwm clock select register
  142:          =000000A3              Pwmprclk:       equ $a3 ;pwm prescale clock select register
  143:          =000000A4              Pwmcae:         equ $a4 ;pwm center align select register
  144:          =000000A5              Pwmctl:         equ $a5 ;pwm control register
  145:          =000000A6              Pwmtst:         equ $a6 ;reserved
  146:          =000000A7              Pwmprsc:        equ $a7 ;reserved
  147:          =000000A8              Pwmscla:        equ $a8 ;pwm scale a
  148:          =000000A9              Pwmsclb:        equ $a9 ;pwm scale b
  149:          =000000AA              Pwmscnta:       equ $aa ;reserved
  150:          =000000AB              Pwmscntb:       equ $ab ;reserved
  151:          =000000AC              Pwmcnt0:        equ $ac ;pwm channel 0 counter
  152:          =000000AD              Pwmcnt1:        equ $ad ;pwm channel 1 counter
  153:          =000000AE              Pwmcnt2:        equ $ae ;pwm channel 2 counter
  154:          =000000AF              Pwmcnt3:        equ $af ;pwm channel 3 counter
  155:          =000000B0              Pwmcnt4:        equ $b0 ;pwm channel 4 counter
  156:          =000000B1              Pwmcnt5:        equ $b1 ;pwm channel 5 counter
  157:          =000000B2              Pwmcnt6:        equ $b2 ;pwm channel 6 counter
  158:          =000000B3              Pwmcnt7:        equ $b3 ;pwm channel 7 counter
  159:          =000000B4              Pwmper0:        equ $b4 ;pwm channel 0 period
  160:          =000000B5              Pwmper1:        equ $b5 ;pwm channel 1 period
  161:          =000000B6              Pwmper2:        equ $b6 ;pwm channel 2 period
  162:          =000000B7              Pwmper3:        equ $b7 ;pwm channel 3 period
  163:          =000000B8              Pwmper4:        equ $b8 ;pwm channel 4 period
  164:          =000000B9              Pwmper5:        equ $b9 ;pwm channel 5 period
  165:          =000000BA              Pwmper6:        equ $ba ;pwm channel 6 period
  166:          =000000BB              Pwmper7:        equ $bb ;pwm channel 7 period
  167:          =000000BC              Pwmdty0:        equ $bc ;pwm channel 0 duty cycle
  168:          =000000BD              Pwmdty1:        equ $bd ;pwm channel 1 duty cycle
  169:          =000000BE              Pwmdty2:        equ $be ;pwm channel 2 duty cycle
  170:          =000000BF              Pwmdty3:        equ $bf ;pwm channel 3 duty cycle
  171:          =000000C0              Pwmdty4:        equ $c0 ;pwm channel 0 duty cycle
  172:          =000000C1              Pwmdty5:        equ $c1 ;pwm channel 1 duty cycle
  173:          =000000C2              Pwmdty6:        equ $c2 ;pwm channel 2 duty cycle
  174:          =000000C3              Pwmdty7:        equ $c3 ;pwm channel 3 duty cycle
  175:          =000000C4              Pwmsdn:         equ $c4 ;pwm shutdown register
  176:                                 
  177:          =000000C8              Sc0bdh:         equ $c8 ;sci 0 baud reg hi byte
  178:          =000000C9              Sc0bdl:         equ $c9 ;sci 0 baud reg lo byte
  179:          =000000CA              Sc0cr1:         equ $ca ;sci 0 control1 reg
  180:          =000000CB              Sc0cr2:         equ $cb ;sci 0 control2 reg
  181:          =000000CC              Sc0sr1:         equ $cc ;sci 0 status reg 1
  182:          =000000CD              Sc0sr2:         equ $cd ;sci 0 status reg 2
  183:          =000000CE              Sc0drh:         equ $ce ;sci 0 data reg hi
  184:          =000000CF              Sc0drl:         equ $cf ;sci 0 data reg lo
  185:          =000000D0              Sc1bdh:         equ $d0 ;sci 1 baud reg hi byte
  186:          =000000D1              Sc1bdl:         equ $d1 ;sci 1 baud reg lo byte
  187:          =000000D2              Sc1cr1:         equ $d2 ;sci 1 control1 reg
  188:          =000000D3              Sc1cr2:         equ $d3 ;sci 1 control2 reg
  189:          =000000D4              Sc1sr1:         equ $d4 ;sci 1 status reg 1
  190:          =000000D5              Sc1sr2:         equ $d5 ;sci 1 status reg 2
  191:          =000000D6              Sc1drh:         equ $d6 ;sci 1 data reg hi
  192:          =000000D7              Sc1drl:         equ $d7 ;sci 1 data reg lo
  193:          =000000D8              Spi0cr1:        equ $d8 ;spi 0 control1 reg
  194:          =000000D9              Spi0cr2:        equ $d9 ;spi 0 control2 reg
  195:          =000000DA              Spi0br:         equ $da ;spi 0 baud reg
  196:          =000000DB              Spi0sr:         equ $db ;spi 0 status reg hi
  197:                                 
  198:          =000000DD              Sp0dr:          equ $dd ;spi 0 data reg
  199:                                 
  200:          =000000E0              Ibad:           equ $e0 ;i2c bus address register
  201:          =000000E1              Ibfd:           equ $e1 ;i2c bus frequency divider
  202:          =000000E2              Ibcr:           equ $e2 ;i2c bus control register
  203:          =000000E3              Ibsr:           equ $e3 ;i2c bus status register
  204:          =000000E4              Ibdr:           equ $e4 ;i2c bus message data register
  205:                                 
  206:          =000000E8              Dlcbcr1:        equ $e8 ;bdlc control regsiter 1
  207:          =000000E9              Dlcbsvr:        equ $e9 ;bdlc state vector register
  208:          =000000EA              Dlcbcr2:        equ $ea ;bdlc control register 2
  209:          =000000EB              Dlcbdr:         equ $eb ;bdlc data register
  210:          =000000EC              Dlcbard:        equ $ec ;bdlc analog delay register
  211:          =000000ED              Dlcbrsr:        equ $ed ;bdlc rate select register
  212:          =000000EE              Dlcscr:         equ $ee ;bdlc control register
  213:          =000000EF              Dlcbstat:       equ $ef ;bdlc status register
  214:          =000000F0              Spi1cr1:        equ $f0 ;spi 1 control1 reg
  215:          =000000F1              Spi1cr2:        equ $f1 ;spi 1 control2 reg
  216:          =000000F2              Spi1br:         equ $f2 ;spi 1 baud reg
  217:          =000000F3              Spi1sr:         equ $f3 ;spi 1 status reg hi
  218:                                 
  219:          =000000F5              Sp1dr:          equ $f5 ;spi 1 data reg
  220:                                 
  221:          =000000F8              Spi2cr1:        equ $f8 ;spi 2 control1 reg
  222:          =000000F9              Spi2cr2:        equ $f9 ;spi 2 control2 reg
  223:          =000000FA              Spi2br:         equ $fa ;spi 2 baud reg
  224:          =000000FB              Spi2sr:         equ $fb ;spi 2 status reg hi
  225:                                 
  226:          =000000FD              Sp2dr:          equ $fd ;spi 2 data reg
  227:                                 
  228:          =00000100              Fclkdiv:        equ $100 ;flash clock divider
  229:          =00000101              Fsec:           equ $101 ;flash security register
  230:                                 
  231:          =00000103              Fcnfg:          equ $103 ;flash configuration register
  232:          =00000104              Fprot:          equ $104 ;flash protection register
  233:          =00000105              Fstat:          equ $105 ;flash status register
  234:          =00000106              Fcmd:           equ $106 ;flash command register
  235:                                 
  236:          =00000110              Eclkdiv:        equ $110 ;eeprom clock divider
  237:                                 
  238:          =00000113              Ecnfg:          equ $113 ;eeprom configuration register
  239:          =00000114              Eprot:          equ $114 ;eeprom protection register
  240:          =00000115              Estat:          equ $115 ;eeprom status register
  241:          =00000116              Ecmd:           equ $116 ;eeprom command register
  242:                                 
  243:          =00000120              Atd1ctl0:       equ $120 ;adc1 control 0 (reserved)
  244:          =00000121              Atd1ctl1:       equ $121 ;adc1 control 1 (reserved)
  245:          =00000122              Atd1ctl2:       equ $122 ;adc1 control 2
  246:          =00000123              Atd1ctl3:       equ $123 ;adc1 control 3
  247:          =00000124              Atd1ctl4:       equ $124 ;adc1 control 4
  248:          =00000125              Atd1ctl5:       equ $125 ;adc1 control 5
  249:          =00000126              Atd1stat:       equ $126 ;adc1 status register hi
  250:                                 *Atd1stat       equ $127 ;adc1 status register lo
  251:          =00000128              Atd1test:       equ $128 ;adc1 test (reserved)
  252:                                 *Atd1test       equ $129 ;
  253:                                 
  254:          =0000012D              Atd1dien:       equ $12d ;adc1 input enable register
  255:                                 
  256:          =0000012F              Portad1:        equ $12f ;port adc1 = input only
  257:          =00000130              Adr10h:         equ $130 ;adc1 result 0 register
  258:          =00000132              Adr11h:         equ $132 ;adc1 result 1 register
  259:          =00000134              Adr12h:         equ $134 ;adc1 result 2 register
  260:          =00000136              Adr13h:         equ $136 ;adc1 result 3 register
  261:          =00000138              Adr14h:         equ $138 ;adc1 result 4 register
  262:          =0000013A              Adr15h:         equ $13a ;adc1 result 5 register
  263:          =0000013C              Adr16h:         equ $13c ;adc1 result 6 register
  264:          =0000013E              Adr17h:         equ $13e ;adc1 result 7 register
  265:          =00000140              Can0ctl0:       equ $140 ;can0 control register 0
  266:          =00000141              Can0ctl1:       equ $141 ;can0 control register 1
  267:          =00000142              Can0btr0:       equ $142 ;can0 bus timing register 0
  268:          =00000143              Can0btr1:       equ $143 ;can0 bus timing register 1
  269:          =00000144              Can0rflg:       equ $144 ;can0 receiver flags
  270:          =00000145              Can0rier:       equ $145 ;can0 receiver interrupt enables
  271:          =00000146              Can0tflg:       equ $146 ;can0 transmit flags
  272:          =00000147              Can0tier:       equ $147 ;can0 transmit interrupt enables
  273:          =00000148              Can0tarq:       equ $148 ;can0 transmit message abort control
  274:          =00000149              Can0taak:       equ $149 ;can0 transmit message abort status
  275:          =0000014A              Can0tbel:       equ $14a ;can0 transmit buffer select
  276:          =0000014B              Can0idac:       equ $14b ;can0 identfier acceptance control
  277:                                 
  278:          =0000014E              Can0rerr:       equ $14e ;can0 receive error counter
  279:          =0000014F              Can0terr:       equ $14f ;can0 transmit error counter
  280:          =00000150              Can0ida0:       equ $150 ;can0 identifier acceptance register 0
  281:          =00000151              Can0ida1:       equ $151 ;can0 identifier acceptance register 1
  282:          =00000152              Can0ida2:       equ $152 ;can0 identifier acceptance register 2
  283:          =00000153              Can0ida3:       equ $153 ;can0 identifier acceptance register 3
  284:          =00000154              Can0idm0:       equ $154 ;can0 identifier mask register 0
  285:          =00000155              Can0idm1:       equ $155 ;can0 identifier mask register 1
  286:          =00000156              Can0idm2:       equ $156 ;can0 identifier mask register 2
  287:          =00000157              Can0idm3:       equ $157 ;can0 identifier mask register 3
  288:          =00000158              Can0ida4:       equ $158 ;can0 identifier acceptance register 4
  289:          =00000159              Can0ida5:       equ $159 ;can0 identifier acceptance register 5
  290:          =0000015A              Can0ida6:       equ $15a ;can0 identifier acceptance register 6
  291:          =0000015B              Can0ida7:       equ $15b ;can0 identifier acceptance register 7
  292:          =0000015C              Can0idm4:       equ $15c ;can0 identifier mask register 4
  293:          =0000015D              Can0idm5:       equ $15d ;can0 identifier mask register 5
  294:          =0000015E              Can0idm6:       equ $15e ;can0 identifier mask register 6
  295:          =0000015F              Can0idm7:       equ $15f ;can0 identifier mask register 7
  296:          =00000160              Can0rxfg:       equ $160 ;can0 rx foreground buffer thru +$16f
  297:          =00000170              Can0txfg:       equ $170 ;can0 tx foreground buffer thru +$17f
  298:                                 
  299:          =00000180              Can1ctl0:       equ $180 ;can1 control register 0
  300:          =00000181              Can1ctl1:       equ $181 ;can1 control register 1
  301:          =00000182              Can1btr0:       equ $182 ;can1 bus timing register 0
  302:          =00000183              Can1btr1:       equ $183 ;can1 bus timing register 1
  303:          =00000184              Can1rflg:       equ $184 ;can1 receiver flags
  304:          =00000185              Can1rier:       equ $185 ;can1 receiver interrupt enables
  305:          =00000186              Can1tflg:       equ $186 ;can1 transmit flags
  306:          =00000187              Can1tier:       equ $187 ;can1 transmit interrupt enables
  307:          =00000188              Can1tarq:       equ $188 ;can1 transmit message abort control
  308:          =00000189              Can1taak:       equ $189 ;can1 transmit message abort status
  309:          =0000018A              Can1tbel:       equ $18a ;can1 transmit buffer select
  310:          =0000018B              Can1idac:       equ $18b ;can1 identfier acceptance control
  311:                                 
  312:          =0000018E              Can1rerr:       equ $18e ;can1 receive error counter
  313:          =0000018F              Can1terr:       equ $18f ;can1 transmit error counter
  314:          =00000190              Can1ida0:       equ $190 ;can1 identifier acceptance register 0
  315:          =00000191              Can1ida1:       equ $191 ;can1 identifier acceptance register 1
  316:          =00000192              Can1ida2:       equ $192 ;can1 identifier acceptance register 2
  317:          =00000193              Can1ida3:       equ $193 ;can1 identifier acceptance register 3
  318:          =00000194              Can1idm0:       equ $194 ;can1 identifier mask register 0
  319:          =00000195              Can1idm1:       equ $195 ;can1 identifier mask register 1
  320:          =00000196              Can1idm2:       equ $196 ;can1 identifier mask register 2
  321:          =00000197              Can1idm3:       equ $197 ;can1 identifier mask register 3
  322:          =00000198              Can1ida4:       equ $198 ;can1 identifier acceptance register 4
  323:          =00000199              Can1ida5:       equ $199 ;can1 identifier acceptance register 5
  324:          =0000019A              Can1ida6:       equ $19a ;can1 identifier acceptance register 6
  325:          =0000019B              Can1ida7:       equ $19b ;can1 identifier acceptance register 7
  326:          =0000019C              Can1idm4:       equ $19c ;can1 identifier mask register 4
  327:          =0000019D              Can1idm5:       equ $19d ;can1 identifier mask register 5
  328:          =0000019E              Can1idm6:       equ $19e ;can1 identifier mask register 6
  329:          =0000019F              Can1idm7:       equ $19f ;can1 identifier mask register 7
  330:          =000001A0              Can1rxfg:       equ $1a0 ;can1 rx foreground buffer thru +$1af
  331:          =000001B0              Can1txfg:       equ $1b0 ;can1 tx foreground buffer thru +$1bf
  332:                                 
  333:          =000001C0              Can2ctl0:       equ $1c0 ;can2 control register 0
  334:          =000001C1              Can2ctl1:       equ $1c1 ;can2 control register 1
  335:          =000001C2              Can2btr0:       equ $1c2 ;can2 bus timing register 0
  336:          =000001C3              Can2btr1:       equ $1c3 ;can2 bus timing register 1
  337:          =000001C4              Can2rflg:       equ $1c4 ;can2 receiver flags
  338:          =000001C5              Can2rier:       equ $1c5 ;can2 receiver interrupt enables
  339:          =000001C6              Can2tflg:       equ $1c6 ;can2 transmit flags
  340:          =000001C7              Can2tier:       equ $1c7 ;can2 transmit interrupt enables
  341:          =000001C8              Can2tarq:       equ $1c8 ;can2 transmit message abort control
  342:          =000001C9              Can2taak:       equ $1c9 ;can2 transmit message abort status
  343:          =000001CA              Can2tbel:       equ $1ca ;can2 transmit buffer select
  344:          =000001CB              Can2idac:       equ $1cb ;can2 identfier acceptance control
  345:                                 
  346:          =000001CE              Can2rerr:       equ $1ce ;can2 receive error counter
  347:          =000001CF              Can2terr:       equ $1cf ;can2 transmit error counter
  348:          =000001D0              Can2ida0:       equ $1d0 ;can2 identifier acceptance register 0
  349:          =000001D1              Can2ida1:       equ $1d1 ;can2 identifier acceptance register 1
  350:          =000001D2              Can2ida2:       equ $1d2 ;can2 identifier acceptance register 2
  351:          =000001D3              Can2ida3:       equ $1d3 ;can2 identifier acceptance register 3
  352:          =000001D4              Can2idm0:       equ $1d4 ;can2 identifier mask register 0
  353:          =000001D5              Can2idm1:       equ $1d5 ;can2 identifier mask register 1
  354:          =000001D6              Can2idm2:       equ $1d6 ;can2 identifier mask register 2
  355:          =000001D7              Can2idm3:       equ $1d7 ;can2 identifier mask register 3
  356:          =000001D8              Can2ida4:       equ $1d8 ;can2 identifier acceptance register 4
  357:          =000001D9              Can2ida5:       equ $1d9 ;can2 identifier acceptance register 5
  358:          =000001DA              Can2ida6:       equ $1da ;can2 identifier acceptance register 6
  359:          =000001DB              Can2ida7:       equ $1db ;can2 identifier acceptance register 7
  360:          =000001DC              Can2idm4:       equ $1dc ;can2 identifier mask register 4
  361:          =000001DD              Can2idm5:       equ $1dd ;can2 identifier mask register 5
  362:          =000001DE              Can2idm6:       equ $1de ;can2 identifier mask register 6
  363:          =000001DF              Can2idm7:       equ $1df ;can2 identifier mask register 7
  364:          =000001E0              Can2rxfg:       equ $1e0 ;can2 rx foreground buffer thru +$1ef
  365:          =000001F0              Can2txfg:       equ $1f0 ;can2 tx foreground buffer thru +$1ff
  366:                                 
  367:          =00000200              Can3ctl0:       equ $200 ;can3 control register 0
  368:          =00000201              Can3ctl1:       equ $201 ;can3 control register 1
  369:          =00000202              Can3btr0:       equ $202 ;can3 bus timing register 0
  370:          =00000203              Can3btr1:       equ $203 ;can3 bus timing register 1
  371:          =00000204              Can3rflg:       equ $204 ;can3 receiver flags
  372:          =00000205              Can3rier:       equ $205 ;can3 receiver interrupt enables
  373:          =00000206              Can3tflg:       equ $206 ;can3 transmit flags
  374:          =00000207              Can3tier:       equ $207 ;can3 transmit interrupt enables
  375:          =00000208              Can3tarq:       equ $208 ;can3 transmit message abort control
  376:          =00000209              Can3taak:       equ $209 ;can3 transmit message abort status
  377:          =0000020A              Can3tbel:       equ $20a ;can3 transmit buffer select
  378:          =0000020B              Can3idac:       equ $20b ;can3 identfier acceptance control
  379:                                 
  380:          =0000020E              Can3rerr:       equ $20e ;can3 receive error counter
  381:          =0000020F              Can3terr:       equ $20f ;can3 transmit error counter
  382:          =00000210              Can3ida0:       equ $210 ;can3 identifier acceptance register 0
  383:          =00000211              Can3ida1:       equ $211 ;can3 identifier acceptance register 1
  384:          =00000212              Can3ida2:       equ $212 ;can3 identifier acceptance register 2
  385:          =00000213              Can3ida3:       equ $213 ;can3 identifier acceptance register 3
  386:          =00000214              Can3idm0:       equ $214 ;can3 identifier mask register 0
  387:          =00000215              Can3idm1:       equ $215 ;can3 identifier mask register 1
  388:          =00000216              Can3idm2:       equ $216 ;can3 identifier mask register 2
  389:          =00000217              Can3idm3:       equ $217 ;can3 identifier mask register 3
  390:          =00000218              Can3ida4:       equ $218 ;can3 identifier acceptance register 4
  391:          =00000219              Can3ida5:       equ $219 ;can3 identifier acceptance register 5
  392:          =0000021A              Can3ida6:       equ $21a ;can3 identifier acceptance register 6
  393:          =0000021B              Can3ida7:       equ $21b ;can3 identifier acceptance register 7
  394:          =0000021C              Can3idm4:       equ $21c ;can3 identifier mask register 4
  395:          =0000021D              Can3idm5:       equ $21d ;can3 identifier mask register 5
  396:          =0000021E              Can3idm6:       equ $21e ;can3 identifier mask register 6
  397:          =0000021F              Can3idm7:       equ $21f ;can3 identifier mask register 7
  398:          =00000220              Can3rxfg:       equ $220 ;can3 rx foreground buffer thru +$22f
  399:          =00000230              Can3txfg:       equ $230 ;can3 tx foreground buffer thru +$23f
  400:                                 
  401:          =00000240              Ptt:            equ $240 ;portt data register
  402:          =00000241              Ptit:           equ $241 ;portt input register
  403:          =00000242              Ddrt:           equ $242 ;portt direction register
  404:          =00000243              Rdrt:           equ $243 ;portt reduced drive register
  405:          =00000244              Pert:           equ $244 ;portt pull device enable
  406:          =00000245              Ppst:           equ $245 ;portt pull polarity select
  407:                                 
  408:          =00000248              Pts:            equ $248 ;ports data register
  409:          =00000249              Ptis:           equ $249 ;ports input register
  410:          =0000024A              Ddrs:           equ $24a ;ports direction register
  411:          =0000024B              Rdrs:           equ $24b ;ports reduced drive register
  412:          =0000024C              Pers:           equ $24c ;ports pull device enable
  413:          =0000024D              Ppss:           equ $24d ;ports pull polarity select
  414:          =0000024E              Woms:           equ $24e ;ports wired or mode register
  415:                                 
  416:          =00000250              Ptm:            equ $250 ;portm data register
  417:          =00000251              Ptim:           equ $251 ;portm input register
  418:          =00000252              Ddrm:           equ $252 ;portm direction register
  419:          =00000253              Rdrm:           equ $253 ;portm reduced drive register
  420:          =00000254              Perm:           equ $254 ;portm pull device enable
  421:          =00000255              Ppsm:           equ $255 ;portm pull polarity select
  422:          =00000256              Womm:           equ $256 ;portm wired or mode register
  423:          =00000257              Modrr:          equ $257 ;portm module routing register
  424:          =00000258              Ptp:            equ $258 ;portp data register
  425:          =00000259              Ptip:           equ $259 ;portp input register
  426:          =0000025A              Ddrp:           equ $25a ;portp direction register
  427:          =0000025B              Rdrp:           equ $25b ;portp reduced drive register
  428:          =0000025C              Perp:           equ $25c ;portp pull device enable
  429:          =0000025D              Ppsp:           equ $25d ;portp pull polarity select
  430:          =0000025E              Piep:           equ $25e ;portp interrupt enable register
  431:          =0000025F              Pifp:           equ $25f ;portp interrupt flag register
  432:          =00000260              Pth:            equ $260 ;porth data register
  433:          =00000261              Ptih:           equ $261 ;porth input register
  434:          =00000262              Ddrh:           equ $262 ;porth direction register
  435:          =00000263              Rdrh:           equ $263 ;porth reduced drive register
  436:          =00000264              Perh:           equ $264 ;porth pull device enable
  437:          =00000265              Ppsh:           equ $265 ;porth pull polarity select
  438:          =00000266              Pieh:           equ $266 ;porth interrupt enable register
  439:          =00000267              Pifh:           equ $267 ;porth interrupt flag register
  440:          =00000268              Ptj:            equ $268 ;portp data register
  441:          =00000269              Ptij:           equ $269 ;portp input register
  442:          =0000026A              Ddrj:           equ $26a ;portp direction register
  443:          =0000026B              Rdrj:           equ $26b ;portp reduced drive register
  444:          =0000026C              Perj:           equ $26c ;portp pull device enable
  445:          =0000026D              Ppsj:           equ $26d ;portp pull polarity select
  446:          =0000026E              Piej:           equ $26e ;portp interrupt enable register
  447:          =0000026F              Pifj:           equ $26f ;portp interrupt flag register
  448:                                 
  449:          =00000280              Can4ctl0:       equ $280 ;can4 control register 0
  450:          =00000281              Can4ctl1:       equ $281 ;can4 control register 1
  451:          =00000282              Can4btr0:       equ $282 ;can4 bus timing register 0
  452:          =00000283              Can4btr1:       equ $283 ;can4 bus timing register 1
  453:          =00000284              Can4rflg:       equ $284 ;can4 receiver flags
  454:          =00000285              Can4rier:       equ $285 ;can4 receiver interrupt enables
  455:          =00000286              Can4tflg:       equ $286 ;can4 transmit flags
  456:          =00000287              Can4tier:       equ $287 ;can4 transmit interrupt enables
  457:          =00000288              Can4tarq:       equ $288 ;can4 transmit message abort control
  458:          =00000289              Can4taak:       equ $289 ;can4 transmit message abort status
  459:          =0000028A              Can4tbel:       equ $28a ;can4 transmit buffer select
  460:          =0000028B              Can4idac:       equ $28b ;can4 identfier acceptance control
  461:                                 
  462:          =0000028E              Can4rerr:       equ $28e ;can4 receive error counter
  463:          =0000028F              Can4terr:       equ $28f ;can4 transmit error counter
  464:          =00000290              Can4ida0:       equ $290 ;can4 identifier acceptance register 0
  465:          =00000291              Can4ida1:       equ $291 ;can4 identifier acceptance register 1
  466:          =00000292              Can4ida2:       equ $292 ;can4 identifier acceptance register 2
  467:          =00000293              Can4ida3:       equ $293 ;can4 identifier acceptance register 3
  468:          =00000294              Can4idm0:       equ $294 ;can4 identifier mask register 0
  469:          =00000295              Can4idm1:       equ $295 ;can4 identifier mask register 1
  470:          =00000296              Can4idm2:       equ $296 ;can4 identifier mask register 2
  471:          =00000297              Can4idm3:       equ $297 ;can4 identifier mask register 3
  472:          =00000298              Can4ida4:       equ $298 ;can4 identifier acceptance register 4
  473:          =00000299              Can4ida5:       equ $299 ;can4 identifier acceptance register 5
  474:          =0000029A              Can4ida6:       equ $29a ;can4 identifier acceptance register 6
  475:          =0000029B              Can4ida7:       equ $29b ;can4 identifier acceptance register 7
  476:          =0000029C              Can4idm4:       equ $29c ;can4 identifier mask register 4
  477:          =0000029D              Can4idm5:       equ $29d ;can4 identifier mask register 5
  478:          =0000029E              Can4idm6:       equ $29e ;can4 identifier mask register 6
  479:          =0000029F              Can4idm7:       equ $29f ;can4 identifier mask register 7
  480:          =000002A0              Can4rxfg:       equ $2a0 ;can4 rx foreground buffer thru +$2af
  481:          =000002B0              Can4txfg:       equ $2b0 ;can4 tx foreground buffer thru +$2bf
  482:                                 
  483:                                 * end registers
  484:                                 
  485:                                         endif   ; end of conditional assembly
   12:                                 
   13:                                 ; Convertion Table
   14:          =00000010              NUMKEYS   EQU 16  ; Number of keys on the keypad
   15:          =000000FF              BADCODE   EQU $FF ; Unsuccessful return of translation
   16:          =00000000              NOKEY     EQU $00 ; No key pressed
   17:          =00000001              POLLCNT   EQU 1   ; Loop number to create 1ms poll time
   18:                                 
   19:                                  SWITCH globalConst ; global constant
   20:                                 
   21:                                 ; Rows
   22:          =000000EF              ROW1 EQU %11101111 ; FIRSTROW  = 1110 1111
   23:          =000000DF              ROW2 EQU %11011111 ; SECONDROW = 1101 1111
   24:          =000000BF              ROW3 EQU %10111111 ; THIRDROW  = 1011 1111
   25:          =0000007F              ROW4 EQU %01111111 ; FORTHROW  = 0111 1111
   26:                                 
   27:                                 ; Define structures
   28:                                  OFFSET 0
   29:     0000 +0001                  trnsTbl_code ds.b 1
   30:     0001 +0001                  trnsTbl_ascii ds.b 1
   31:          =00000002              trnsTbl_struct_len EQU *
   32:                                 
   33:                                 ; Translation Table
   34:     0000 EE 31                  trnsTbl dc.b %11101110,'1'
   35:     0002 ED 32                          dc.b %11101101,'2'
   36:     0004 EB 33                          dc.b %11101011,'3'
   37:     0006 E7 61                          dc.b %11100111,'a'
   38:     0008 DE 34                          dc.b %11011110,'4'
   39:     000A DD 35                          dc.b %11011101,'5'
   40:     000C DB 36                          dc.b %11011011,'6'
   41:     000E D7 62                          dc.b %11010111,'b'
   42:     0010 BE 37                          dc.b %10111110,'7'
   43:     0012 BD 38                          dc.b %10111101,'8'
   44:     0014 BB 39                          dc.b %10111011,'9'
   45:     0016 B7 63                          dc.b %10110111,'c'
   46:     0018 7E 2A                          dc.b %01111110,'*'
   47:     001A 7D 30                          dc.b %01111101,'0'
   48:     001C 7B 23                          dc.b %01111011,'#'
   49:     001E 77 64                          dc.b %01110111,'d'
   50:                                 
   51:                                  SWITCH code_section ; place in code section
   52:                                 
   53:                                 ;------------------------------------------------------
   54:                                 ; Subroutine: initKeyPad
   55:                                 ; Parameters: none
   56:                                 ; Returns: none
   57:                                 ; Local Variables: none
   58:                                 ; Global Variables: none
   59:                                 ; Descriptions: Initiates PORTA
   60:                                 ;               Bit 0 to 3 are inputs
   61:                                 ;               Bit 4 to 7 are outputs
   62:                                 ;               Enables pull up
   63:                                 ;------------------------------------------------------
   64:     2000                        initKeyPad:
   65:     2000 180B F0 0002              movb #$f0,DDRA ; DDRA = 0x0f
   66:     2005 180B 01 000C              movb #$01,PUCR ; PUCR = 00000001
   67:     200A 3D                        rts
   68:                                 
   69:                                 ;------------------------------------------------------
   70:                                 ; Subroutine: pollReadKey
   71:                                 ; Parameters: none
   72:                                 ; Returns: input - NOKEY if no inputs
   73:                                 ;                  otherwise ASCII code in acc. B
   74:                                 ; Local Variables: code  - store into acc. B
   75:                                 ;                  input - store into acc. B
   76:                                 ;                  cnt   - counter, creates 10ms delay
   77:                                 ; Global Variables: none
   78:                                 ; Descriptions: Checks if there are any inputs from 
   79:                                 ;               the keypad, if so, delay 2ms and then
   80:                                 ;               checks again. Calls readKey if input
   81:                                 ;               detected.
   82:                                 ;------------------------------------------------------
   83:                                 ; Stack Usage
   84:                                         OFFSET 0 ; set offset to stack
   85:     0000 +0001                  PRK_INPUT DS.B 1 ; return value, in ASCII
   86:     0001                        PRK_VARSIZE:
   87:     0001 +0002                  PRK_PR_X  DS.W 1 ; Preserve X for cnt
   88:     0003 +0002                  PRK_RA    DS.W 1 ; Return address
   89:                                 
   90:     200B 34                     pollReadKey: pshx           ; int cnt
   91:     200C 1B 9F                     leas -PRK_VARSIZE,SP     ; load effective addr into SP
   92:     200E 1808 80 00                movb #NOKEY,PRK_INPUT,SP ; input = NOKEY
   93:     2012 CE 0001                   ldx #POLLCNT             ; cnt = POLLCNT
   94:     2015 180B 0F 0000              movb #$0f,PORTA           ; PORTA = 0x0f
   95:     201A                        prkloop1:
   96:     201A                        prkif1:
   97:     201A D6 00                     ldab PORTA
   98:     201C C1 0F                     cmpb #$0f
   99:     201E 27 10                     beq prkendif1            ; if (PORTA != 0x0f)
  100:     2020 CC 0002                   ldd #2
C:\Users\Lenovo\Desktop\AlarmAssembler\keyPad.asm(101): Error A2038: col(15) 'delayms': undefined symbol
  101:                                    jsr delayms              ; delayms(2)
  102:     2023                        prkif2:
  103:     2023 D6 00                     ldab PORTA
  104:     2025 C1 0F                     cmpb #$0f
  105:     2027 27 07                     beq prkendif2            ; if (PORTA != 0x0f)
  106:     2029 16 2039                   jsr readKey
  107:     202C 6B 80                     stab PRK_INPUT,SP        ; input = readKey()
  108:     202E 20 03                     bra prkendloop1
  109:     2030                        prkendif2
  110:     2030                        prkendif1
  111:     2030 09                        dex                      ; cnt--
  112:     2031 26 E7                     bne prkloop1             ; while (cnt != 0)
  113:     2033                        prkendloop1
  114:     2033 E6 80                     ldab PRK_INPUT,SP        ; return(input)
  115:                                    ; Restore stack and regs
  116:     2035 1B 81                     leas PRK_VARSIZE,SP
  117:     2037 30                        pulx
  118:     2038 3D                        rts
  119:                                 
  120:                                 ;------------------------------------------------------
  121:                                 ; Subroutine: readKey
  122:                                 ; Parameters: none
  123:                                 ; Returns: ch - ASCII code, stored in acc. B
  124:                                 ; Local Variables: ch - in acc. B
  125:                                 ;                  keycode - on stack 
  126:                                 ; Global Variables: none
  127:                                 ; Descriptions: Reads code from the keypad using
  128:                                 ;               subroutine keyInput. The code will then
  129:                                 ;               be translated into ASCII code using the
  130:                                 ;               subroutine translate.
  131:                                 ;------------------------------------------------------
  132:                                 ; Stack Usage
  133:                                         OFFSET 0 ; set offset to stack
  134:     0000 +0001                  RK_KEYCODE DS.B 1 ; keycode var.
  135:     0001 +0001                  RK_VARSIZE DS.B 1 ; Preserve acc. A
  136:     0002 +0002                  RK_RA      DS.W 1 ; Return address
  137:                                 
  138:     2039 36                     readKey: psha               ; byte keycode
  139:     203A 1B 9F                     leas -RK_VARSIZE,SP
  140:     203C                        rkloop1:
  141:     203C 180C 000F 0000            movb $0F,PORTA           ; PORTA = 0x0f
  142:     2042                        rkloop2:
  143:     2042 D6 00                     ldab PORTA
  144:     2044 C1 0F                     cmpb #$0F
  145:     2046 27 FA                     beq rkloop2              ; while (PORTA == 0x0f)
  146:     2048 1809 80 0000              movb PORTA,RK_KEYCODE,SP ; keycode = PORTA
  147:     204D CC 000A                   ldd #10
C:\Users\Lenovo\Desktop\AlarmAssembler\keyPad.asm(148): Error A2038: col(15) 'delayms': undefined symbol
  148:                                    jsr delayms              ; delayms(10)
  149:     2050 D6 00                     ldab PORTA
  150:     2052 E1 80                     cmpb RK_KEYCODE,SP
  151:     2054 26 E6                     bne rkloop1              ; while (keycode != PORTA)
  152:     2056 16 2072                   jsr keyInput
  153:     2059 6B 80                     stab RK_KEYCODE,SP       ; keycode = keyInput()
  154:     205B 180B 0F 0000              movb #$0F,PORTA           ; PORTA = 0x0f
  155:     2060                        rkloop3:
  156:     2060 D6 00                     ldab PORTA
  157:     2062 C1 0F                     cmpb #$0F
  158:     2064 26 FA                     bne rkloop3              ; while (PORTA != 0x0f)
  159:     2066 CC 000A                   ldd #10
C:\Users\Lenovo\Desktop\AlarmAssembler\keyPad.asm(160): Error A2038: col(15) 'delayms': undefined symbol
  160:                                    jsr delayms              ; delayms(10)
  161:     2069 E6 80                     ldab RK_KEYCODE,SP
  162:     206B 16 209B                   jsr translate            ; ch = translate(keycode)
  163:                                    ; Restore stack and regs
  164:     206E 1B 81                     leas RK_VARSIZE,SP
  165:     2070 32                        pula
  166:     2071 3D                        rts                      ; return(ch)
  167:                                 
  168:                                 ;------------------------------------------------------
  169:                                 ; Subroutine: keyInput
  170:                                 ; Parameters: none
  171:                                 ; Returns: keyinput - keycode of the key pressed, in 
  172:                                 ;                     acc. B
  173:                                 ; Local Variables: keyinput - in acc. B
  174:                                 ; Global Variables: none
  175:                                 ; Descriptions: If low level is found on one of the
  176:                                 ;               input pins, return the input.
  177:                                 ;------------------------------------------------------
  178:     2072                        keyInput:
  179:     2072 180B EF 0000              movb #ROW1,PORTA ; PORTA = FIRSTROW
  180:     2077                        kiif1:
  181:     2077 D6 00                     ldab PORTA
  182:     2079 C1 EF                     cmpb #ROW1
  183:     207B 26 1B                     bne kiendif1     ; if (PORTA == FIRSTROW)
  184:     207D 180B DF 0000              movb #ROW2,PORTA ; PORTA = SECONDROW
  185:     2082                        kiif2:
  186:     2082 D6 00                     ldab PORTA
  187:     2084 C1 DF                     cmpb #ROW2
  188:     2086 26 10                     bne kiendif2     ; if (PORTA == SECONDROW)
  189:     2088 180B BF 0000              movb #ROW3,PORTA ; PORTA = THRIDROW
  190:     208D                        kiif3:
  191:     208D D6 00                     ldab PORTA
  192:     208F C1 BF                     cmpb #ROW3
  193:     2091 26 05                     bne kiendif3     ; if (PORTA == THIRDROW)
  194:     2093 180B 7F 0000              movb #ROW4,PORTA ; PORTA = FORTHROW
  195:     2098                        kiendif1
  196:     2098                        kiendif2
  197:     2098                        kiendif3
  198:     2098 D6 00                     ldab PORTA       ; keyinput = PORTA
  199:     209A 3D                        rts              ; return(keyinput)
  200:                                 
  201:                                 ;------------------------------------------------------
  202:                                 ; Subroutine: translate
  203:                                 ; Parameters: input - keycode read from keypad, in 
  204:                                 ;             acc B
  205:                                 ; Returns: ch - character in ASCII code, in acc. B
  206:                                 ; Local Variables: ptr - pointer to translation table,
  207:                                 ;                        in reg X
  208:                                 ;                  cnt - counter, in acc A
  209:                                 ; Global Variables: none
  210:                                 ; Descriptions: Use the translation table to translate
  211:                                 ;               the keycode into ASCII codes. If no
  212:                                 ;               value is found, BADCODE is returned.
  213:                                 ;------------------------------------------------------
  214:                                 ; Stack Usage
  215:                                         OFFSET 0
  216:     0000 +0001                  TL_CH DS.B 1   ; Return var
  217:     0001 +0001                  TL_PR_A DS.B 1 ; Preserved A for cnt
  218:     0002 +0001                  TL_PR_X DS.B 1 ; Preserved X for code
  219:     0003 +0002                  TL_RA DS.W 1   ; Return addr
  220:                                 
  221:     209B 36                     translate: psha
  222:     209C 34                        pshx
  223:     209D 1B 9F                     leas -1,SP                    ; byte ch
  224:     209F CE 0000                   ldx #trnsTbl                  ; ptr = trnsTbl
  225:     20A2 87                        clra                          ; cnt = 0
  226:     20A3 1808 80 FF                movb #BADCODE,TL_CH,SP        ; ch = BADCODE
  227:     20A7                        tlloop1:
  228:     20A7 E1 00                     cmpb trnsTbl_code,X
  229:     20A9 26 06                     bne tlendif1                  ; if(input == (ptr = code))
  230:     20AB 180A 01 80                movb trnsTbl_ascii,X,TL_CH,SP ; ch = [ptr+1]
  231:     20AF 20 07                     bra tlendloop1
  232:     20B1                        tlendif1:
  233:     20B1 1A 02                     leax trnsTbl_struct_len,X     ; ptr++
  234:     20B3 42                        inca ; cnt++
  235:     20B4 81 10                     cmpa #NUMKEYS
  236:     20B6 25 EF                     blo tlloop1                   ; while (cnt < NUMKEYS)
  237:     20B8                        tlendloop1
  238:                                    ; Restore regs
  239:     20B8 33                        pulb
  240:     20B9 30                        pulx
  241:     20BA 32                        pula
  242:     20BB 3D                        rts

Symbols:
badcode                         *000000ff
ddra                            *00000002
delayms                         ?00000000
endcode                         ?00000000
keyinput                        *00002072
kiendif1                        *00002098
kiendif2                        *00002098
kiendif3                        *00002098
nokey                           *00000000
numkeys                         *00000010
pollcnt                         *00000001
porta                           *00000000
prk_input                       *00000000
prk_varsize                     *00000001
prkendif1                       *00002030
prkendif2                       *00002030
prkendloop1                     *00002033
prkloop1                        *0000201a
program                         *00002000
pucr                            *0000000c
readkey                         *00002039
rk_keycode                      *00000000
rk_varsize                      *00000001
rkloop1                         *0000203c
rkloop2                         *00002042
rkloop3                         *00002060
row1                            *000000ef
row2                            *000000df
row3                            *000000bf
row4                            *0000007f
tl_ch                           *00000000
tlendif1                        *000020b1
tlendloop1                      *000020b8
tlloop1                         *000020a7
translate                       *0000209b
trnstbl                         *00000000
trnstbl_ascii                   *00000001
trnstbl_code                    *00000000
trnstbl_struct_len              *00000002
variables                       *00003000

